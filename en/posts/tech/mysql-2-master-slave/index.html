<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>mysql (二) 主从复制原理 GTID 并行复制 | lvbibir's Blog</title>
<meta name=keywords content="mysql"><meta name=description content="mysql 主从复制的详细原理, 主从复制模式, 主从复制方式, 以及 GTID 复制和并行复制"><meta name=author content="作者:&nbsp;lvbibir"><link rel=canonical href=https://www.lvbibir.cn/en/posts/tech/mysql-2-master-slave/><link crossorigin=anonymous href=/assets/css/stylesheet.496206d0375c7e7a3b42446d2f3ea1b7983a46d6cd89bb72427af041495cbd41.css integrity="sha256-SWIG0Ddcfno7QkRtLz6ht5g6RtbNibtyQnrwQUlcvUE=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.lvbibir.cn/img/avatar.gif><link rel=icon type=image/png sizes=16x16 href=https://www.lvbibir.cn/img/avatar.gif><link rel=icon type=image/png sizes=32x32 href=https://www.lvbibir.cn/img/avatar.gif><link rel=apple-touch-icon href=https://www.lvbibir.cn/img/avatar.gif><link rel=mask-icon href=https://www.lvbibir.cn/img/avatar.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.lvbibir.cn/en/posts/tech/mysql-2-master-slave/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="mysql (二) 主从复制原理 GTID 并行复制"><meta property="og:description" content="mysql 主从复制的详细原理, 主从复制模式, 主从复制方式, 以及 GTID 复制和并行复制"><meta property="og:type" content="article"><meta property="og:url" content="https://www.lvbibir.cn/en/posts/tech/mysql-2-master-slave/"><meta property="og:image" content="https://image.lvbibir.cn/blog/mysql.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-03T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-28T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://image.lvbibir.cn/blog/mysql.png"><meta name=twitter:title content="mysql (二) 主从复制原理 GTID 并行复制"><meta name=twitter:description content="mysql 主从复制的详细原理, 主从复制模式, 主从复制方式, 以及 GTID 复制和并行复制"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚 文章","item":"https://www.lvbibir.cn/en/posts/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻 技术","item":"https://www.lvbibir.cn/en/posts/tech/"},{"@type":"ListItem","position":3,"name":"mysql (二) 主从复制原理 GTID 并行复制","item":"https://www.lvbibir.cn/en/posts/tech/mysql-2-master-slave/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"mysql (二) 主从复制原理 GTID 并行复制","name":"mysql (二) 主从复制原理 GTID 并行复制","description":"mysql 主从复制的详细原理, 主从复制模式, 主从复制方式, 以及 GTID 复制和并行复制","keywords":["mysql"],"articleBody":"0 前言 本文参考以下链接:\n【MySQL】主从复制实现原理详解 基于 centos-7.9 mysql-5.7.42\nmysql 安装参考 mysql 系列文章\n1 主从复制原理 主从复制涉及到 3 个线程, 4 个文件\n1.1 线程 master:\nlog dump : 当 slave 连接 master 时, 主节点会为其创建一个 log dump 线程, 用于发送和读取 binlog 的内容. 在读取 binlog 中的操作时, log dump 线程会对主节点上的 binlog 加锁, 当读取完成, 在发送给从节点之前, 锁会被释放.\n主节点会为自己的每一个从节点创建一个 log dump 线程 .\nslave:\nIO : 接受 master 发送的 binlog 文件位置的副本. 然后将数据的更新记录到 relaylog 中. SQL : 负责读取 relaylog 中的内容, 解析成具体的操作并执行, 最终保证主从数据的一致性 1.2 文件 master:\nbinlog : 二进制文件, 记录库中的信息 slave:\nrelaylog : 中继日志, 用来同步 master 的 binlog relaylog.info : 记录文件复制的进度. master.info : 存放 master 信息, 以及上次读取到的 master 同步过来的 binlog 的位置 1.3 详细步骤 slave 执行 change master to 命令 ( master 的连接信息 + 复制的起点), 将以上信息记录到 master.info 文件 slave 执行 start slave 命令,开启 IO 线程和 SQL 线程 slave 的 IO 线程读取 master.info 文件中的信息, 获取到 IP, PORT, User, Pass, binlog 的位置信息 slave 的 IO 线程请求连接 master, master 提供一个 log dump 线程, 负责和 IO 线程交互 IO 线程根据 binlog 的位置信息 (mysql-bin.000004 , 444), 请求 master 新的 binlog master 通过 log dump 线程将最新的 binlog 传输给 slave 的 IO 线程 IO 线程接收到新的 binlog 日志, 存储到 TCP/IP 缓存, 立即返回 ACK 给 master , 并更新 master.info IO 线程将 TCP/IP 缓存中的数据, 转储到磁盘 relaylog 中 SQL 线程读取 relaylog.info 中的信息, 获取到上次已经应用过的 relaylog 的位置信息 SQL 线程会按照上次的位置点回放最新的 relaylog, 再次更新 relaylog.info 信息 slave 会自动 purge 应用过的 relaylog 进行定期清理 2 主从复制模式 mysql 默认一般为异步同步数据\n2.1 全同步 当 mster 执行完一个事务, 然后所有的 slave 都复制了该事务并成功执行完才返回成功信息给客户端. 因为需要等待所有 slave 执行完该事务才能返回成功信息, 所以全同步复制的性能必然会收到严重的影响.\n2.2 半同步 介于异步复制和全同步复制之间, master 在执行完客户端提交的事务后不是立刻返回给客户端, 而是等待至少一个 slave 接收到并写到 relaylog 中才返回成功信息给客户端 (只能保证 master 的 binlog 至少传输到了一个 slave 上, 但并不能保证 slave 将此事务执行更新到 db 中), 否则需要等待直到超时时间然后切换成异步模式再提交. 相对于异步复制, 半同步复制提高了数据的安全性, 一定程度的保证了数据能成功备份到 slave, 同时它也造成了一定程度的延迟, 但是比全同步模式延迟要低, 这个延迟最少是一个 TCP/IP 往返的时间. 所以, 半同步复制最好在低延时的网络中使用.\n2.3 异步 master 不会主动推送 binlog 到 slave, master 在执行完客户端提交的事务后会立即将结果返给给客户端, 并不关心 slave 是否已经接收并处理, 这样就会有一个问题, master 如果崩溃掉了, 此时 master 上已经提交的事务可能并没有传到 slave 上, 如果此时, 强行将 slave 提升为 master, 可能导致新 master 节点上的数据不完整.\n3 主从复制方式 MySQL 主从复制有三种方式: 基于 SQL 语句的复制 (statement-based replication, SBR), 基于行的复制 (row-based replication, RBR), 混合模式复制 (mixed-based replication, MBR). 对应的 bin-log 文件的格式也有三种: STATEMENT, ROW, MIXED\n可通过如下命令查看 binlog 格式\nSHOW VARIABLES LIKE \"binlog_format\"; 3.1 SBR 就是记录 sql 语句在 bin-log 中, Mysql 5.1.4 及之前的版本都是使用的这种复制格式. 优点是只需要记录会修改数据的 sql 语句到 bin-log 中, 减少了 bin-log 日质量, 节约 I/O, 提高性能. 缺点是在某些情况下, 会导致主从节点中数据不一致 (比如 sleep(), now() 等).\n3.2 RBR mysql master 将 SQL 语句分解为基于 Row 更改的语句并记录在 bin-log 中, 也就是只记录哪条数据被修改了, 修改成什么样. 优点是不会出现某些特定情况下的存储过程、或者函数、或者 trigger 的调用或者触发无法被正确复制的问题. 缺点是会产生大量的日志, 尤其是修改 table 的时候会让日志暴增,同时增加 bin-log 同步时间. 也不能通过 bin-log 解析获取执行过的 sql 语句, 只能看到发生的 data 变更.\n3.3 MBR MySQL NDB cluster 7.3 和 7.4 使用的 MBR. 是以上两种模式的混合, 对于一般的复制使用 STATEMENT 模式保存到 bin-log, 对于 STATEMENT 模式无法复制的操作则使用 ROW 模式来保存, MySQL 会根据执行的 SQL 语句选择日志保存方式.\n4 GTID 复制 在原来基于日志的复制中, slave 需要告知 master 要从哪个偏移量进行增量同步, 如果指定错误会造成数据的遗漏, 从而造成数据的不一致.\n而基于 GTID 的复制中, slave 会告知 master 已经执行的事务的 GTID 的值, 然后 master 会将所有未执行的事务的 GTID 的列表返回给 slave. 并且可以保证同一个事务只在指定的 slave 执行一次. 通过全局的事务 ID 确定 slave 要执行的事务的方式代替了以前需要用 binlog 和 pos 点确定 slave 要执行的事务的方式.\nGTID 是由 server_uuid 和事物 id 组成, 格式为: GTID=server_uuid:transaction_id. server_uuid 是在数据库启动过程中自动生成, 每台机器的 server-uuid 不一样. uuid 存放在数据目录的 auto.cnf 文件中，而 transaction_id 就是事务提交时系统顺序分配的一个不会重复的序列号\nmaster 更新数据时, 会在事务前产生 GTID, 一起记录到 binlog 日志中. slave 的 IO 线程将变更的 binlog 写入到本地的 relaylog 中. SQL 线程从 relaylog 中获取 GTID, 然后对比本地 binlog 是否有记录 (所以 slave 必须要开启 binlog, 并且将 log_slave_updates 设置为 ON). 如果有记录，说明该 GTID 的事务已经执行, slave 会忽略. 如果没有记录, slave 就会从 relaylog 中执行该 GTID 的事务, 并记录到 binlog. 在解析过程中会判断是否有主键, 如果没有就用二级索引, 如果有就用全部扫描.\n5 并行复制 master 大多数情况下都是多线程多客户端去写, 而 slave 只有一个 SQL 线程进行写, 无法避免地会出现主从复制的延迟问题, 并行复制可以指定线程数量, 从而提高 slave 写的速度.\n在 mysql 5.6 版本之后引入了并行复制的概念\n通过上图我们可以发现其实所谓的并行复制, 就是在中间添加了一个分发的环节, 也就是说原来的 SQL 线程变成了现在的 coordinator 组件, 当 relaylog 日志更新后, coordinator 负责读取日志信息以及分发事务, 真正的执行过程是放在了 worker 线程上, 由多个线程并行的去执行.\n# 查看并行的slave的线程的个数，默认是0.表示单线程 show global variables like 'slave_parallel_workers'; # 根据实际情况保证开启多少线程 set global slave_parallel_workers = 4; # 设置并发复制的方式，默认是一个线程处理一个库，值为database show global variables like '%slave_parallel_type%'; # 停止slave stop slave; # 设置属性值 set global slave_parallel_type='logical_check'; # 开启slave start slave # 查看线程数 show full processlist; 以上\n","wordCount":"2245","inLanguage":"en","image":"https://image.lvbibir.cn/blog/mysql.png","datePublished":"2022-05-03T00:00:00Z","dateModified":"2024-01-28T00:00:00Z","author":{"@type":"Person","name":"lvbibir"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.lvbibir.cn/en/posts/tech/mysql-2-master-slave/"},"publisher":{"@type":"Organization","name":"lvbibir's Blog","logo":{"@type":"ImageObject","url":"https://www.lvbibir.cn/img/avatar.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.lvbibir.cn/en/ accesskey=h title="lvbibir's Blog (Alt + H)"><img src=https://www.lvbibir.cn/img/avatar.gif alt aria-label=logo height=35>lvbibir's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li class=menu-item><a href=https://www.lvbibir.cn/en/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li class=menu-item><a href=https://www.lvbibir.cn/en/posts title="📚 文章"><span>📚 文章</span></a></li><li class=menu-item><a href=https://www.lvbibir.cn/en/archives title="📈 归档"><span>📈 归档</span></a></li><li class=menu-item><a href=https://www.lvbibir.cn/en/talk title="💬 说说"><span>💬 说说</span></a></li><li class=menu-item><a href=https://www.lvbibir.cn/en/links title="🤝 友链"><span>🤝 友链</span></a></li></ul></nav></header><main class="main page"><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://www.lvbibir.cn/en/>主页</a>&nbsp;»&nbsp;<a href=https://www.lvbibir.cn/en/posts/>📚 文章</a>&nbsp;»&nbsp;<a href=https://www.lvbibir.cn/en/posts/tech/>👨🏻‍💻 技术</a></div><h1 class=post-title>mysql (二) 主从复制原理 GTID 并行复制</h1><div class=post-description>mysql 主从复制的详细原理, 主从复制模式, 主从复制方式, 以及 GTID 复制和并行复制</div><div class=post-meta>创建:&amp;nbsp;&lt;span title='2022-05-03 00:00:00 +0000 UTC'>2022-05-03&lt;/span>&amp;nbsp;|&amp;nbsp;更新:&amp;nbsp;2024-01-28&amp;nbsp;|&amp;nbsp;字数:&amp;nbsp;2245字&amp;nbsp;|&amp;nbsp;作者:&amp;nbsp;lvbibir
|&nbsp;标签:&nbsp;<ul class=post-tags-meta><a href=https://www.lvbibir.cn/en/tags/mysql/>Mysql</a></ul><span id=busuanzi_container_page_pv>&nbsp;|&nbsp;访问:&nbsp;<span id=busuanzi_value_page_pv></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>文章目录</span></summary><div class=inner><ul><li><a href=#0-%e5%89%8d%e8%a8%80 aria-label="0 前言">0 前言</a></li><li><a href=#1-%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%e5%8e%9f%e7%90%86 aria-label="1 主从复制原理">1 主从复制原理</a><ul><li><a href=#11-%e7%ba%bf%e7%a8%8b aria-label="1.1 线程">1.1 线程</a></li><li><a href=#12-%e6%96%87%e4%bb%b6 aria-label="1.2 文件">1.2 文件</a></li><li><a href=#13-%e8%af%a6%e7%bb%86%e6%ad%a5%e9%aa%a4 aria-label="1.3 详细步骤">1.3 详细步骤</a></li></ul></li><li><a href=#2-%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%e6%a8%a1%e5%bc%8f aria-label="2 主从复制模式">2 主从复制模式</a><ul><li><a href=#21-%e5%85%a8%e5%90%8c%e6%ad%a5 aria-label="2.1 全同步">2.1 全同步</a></li><li><a href=#22-%e5%8d%8a%e5%90%8c%e6%ad%a5 aria-label="2.2 半同步">2.2 半同步</a></li><li><a href=#23-%e5%bc%82%e6%ad%a5 aria-label="2.3 异步">2.3 异步</a></li></ul></li><li><a href=#3-%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%e6%96%b9%e5%bc%8f aria-label="3 主从复制方式">3 主从复制方式</a><ul><li><a href=#31-sbr aria-label="3.1 SBR">3.1 SBR</a></li><li><a href=#32-rbr aria-label="3.2 RBR">3.2 RBR</a></li><li><a href=#33-mbr aria-label="3.3 MBR">3.3 MBR</a></li></ul></li><li><a href=#4-gtid-%e5%a4%8d%e5%88%b6 aria-label="4 GTID 复制">4 GTID 复制</a></li><li><a href=#5-%e5%b9%b6%e8%a1%8c%e5%a4%8d%e5%88%b6 aria-label="5 并行复制">5 并行复制</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=0-前言>0 前言<a hidden class=anchor aria-hidden=true href=#0-前言>#</a></h1><p>本文参考以下链接:</p><ul><li><a href=https://blog.nowcoder.net/n/b90c959437734a8583fddeaa6d102e43 target=_blank rel=noopener style=color:#42b983 ;>【MySQL】主从复制实现原理详解</a></li></ul><p>基于 <code>centos-7.9</code> <code>mysql-5.7.42</code></p><p>mysql 安装参考 <a href=https://www.lvbibir.cn/tags/mysql target=_blank rel=noopener style=color:#42b983 ;>mysql 系列文章</a></p><h1 id=1-主从复制原理>1 主从复制原理<a hidden class=anchor aria-hidden=true href=#1-主从复制原理>#</a></h1><p>主从复制涉及到 3 个线程, 4 个文件</p><p><img loading=lazy src=https://image.lvbibir.cn/blog/v2-12f36a0aa2ea88020809173182e54e73_1440w.webp alt=v2-12f36a0aa2ea88020809173182e54e73_1440w></p><h2 id=11-线程>1.1 线程<a hidden class=anchor aria-hidden=true href=#11-线程>#</a></h2><p>master:</p><ul><li><p>log dump : 当 slave 连接 master 时, 主节点会为其创建一个 log dump 线程, 用于发送和读取 binlog 的内容. 在读取 binlog 中的操作时, log dump 线程会对主节点上的 binlog 加锁, 当读取完成, 在发送给从节点之前, 锁会被释放.</p><p>主节点会为自己的每一个从节点创建一个 log dump 线程 .</p></li></ul><p>slave:</p><ul><li>IO : 接受 master 发送的 binlog 文件位置的副本. 然后将数据的更新记录到 relaylog 中.</li><li>SQL : 负责读取 relaylog 中的内容, 解析成具体的操作并执行, 最终保证主从数据的一致性</li></ul><h2 id=12-文件>1.2 文件<a hidden class=anchor aria-hidden=true href=#12-文件>#</a></h2><p>master:</p><ul><li>binlog : 二进制文件, 记录库中的信息</li></ul><p>slave:</p><ul><li>relaylog : 中继日志, 用来同步 master 的 binlog</li><li>relaylog.info : 记录文件复制的进度.</li><li>master.info : 存放 master 信息, 以及上次读取到的 master 同步过来的 binlog 的位置</li></ul><h2 id=13-详细步骤>1.3 详细步骤<a hidden class=anchor aria-hidden=true href=#13-详细步骤>#</a></h2><ul><li>slave 执行 <code>change master to</code> 命令 ( master 的连接信息 + 复制的起点), 将以上信息记录到 master.info 文件</li><li>slave 执行 <code>start slave</code> 命令,开启 IO 线程和 SQL 线程</li><li>slave 的 IO 线程读取 master.info 文件中的信息, 获取到 IP, PORT, User, Pass, binlog 的位置信息</li><li>slave 的 IO 线程请求连接 master, master 提供一个 log dump 线程, 负责和 IO 线程交互</li><li>IO 线程根据 binlog 的位置信息 (mysql-bin.000004 , 444), 请求 master 新的 binlog</li><li>master 通过 log dump 线程将最新的 binlog 传输给 slave 的 IO 线程</li><li>IO 线程接收到新的 binlog 日志, 存储到 TCP/IP 缓存, 立即返回 ACK 给 master , 并更新 master.info</li><li>IO 线程将 TCP/IP 缓存中的数据, 转储到磁盘 relaylog 中</li><li>SQL 线程读取 relaylog.info 中的信息, 获取到上次已经应用过的 relaylog 的位置信息</li><li>SQL 线程会按照上次的位置点回放最新的 relaylog, 再次更新 relaylog.info 信息</li><li>slave 会自动 purge 应用过的 relaylog 进行定期清理</li></ul><h1 id=2-主从复制模式>2 主从复制模式<a hidden class=anchor aria-hidden=true href=#2-主从复制模式>#</a></h1><p>mysql 默认一般为异步同步数据</p><h2 id=21-全同步>2.1 全同步<a hidden class=anchor aria-hidden=true href=#21-全同步>#</a></h2><p>当 mster 执行完一个事务, 然后所有的 slave 都复制了该事务并成功执行完才返回成功信息给客户端. 因为需要等待所有 slave 执行完该事务才能返回成功信息, 所以全同步复制的性能必然会收到严重的影响.</p><h2 id=22-半同步>2.2 半同步<a hidden class=anchor aria-hidden=true href=#22-半同步>#</a></h2><p>介于异步复制和全同步复制之间, master 在执行完客户端提交的事务后不是立刻返回给客户端, 而是等待至少一个 slave 接收到并写到 relaylog 中才返回成功信息给客户端 (只能保证 master 的 binlog 至少传输到了一个 slave 上, 但并不能保证 slave 将此事务执行更新到 db 中), 否则需要等待直到超时时间然后切换成异步模式再提交. 相对于异步复制, 半同步复制提高了数据的安全性, 一定程度的保证了数据能成功备份到 slave, 同时它也造成了一定程度的延迟, 但是比全同步模式延迟要低, 这个延迟最少是一个 TCP/IP 往返的时间. 所以, 半同步复制最好在低延时的网络中使用.</p><h2 id=23-异步>2.3 异步<a hidden class=anchor aria-hidden=true href=#23-异步>#</a></h2><p>master 不会主动推送 binlog 到 slave, master 在执行完客户端提交的事务后会立即将结果返给给客户端, 并不关心 slave 是否已经接收并处理, 这样就会有一个问题, master 如果崩溃掉了, 此时 master 上已经提交的事务可能并没有传到 slave 上, 如果此时, 强行将 slave 提升为 master, 可能导致新 master 节点上的数据不完整.</p><h1 id=3-主从复制方式>3 主从复制方式<a hidden class=anchor aria-hidden=true href=#3-主从复制方式>#</a></h1><p>MySQL 主从复制有三种方式: 基于 SQL 语句的复制 (statement-based replication, SBR), 基于行的复制 (row-based replication, RBR), 混合模式复制 (mixed-based replication, MBR). 对应的 bin-log 文件的格式也有三种: STATEMENT, ROW, MIXED</p><p>可通过如下命令查看 binlog 格式</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>SHOW VARIABLES LIKE <span style=color:#48b685>&#34;binlog_format&#34;</span>;
</span></span></code></pre></div><h2 id=31-sbr>3.1 SBR<a hidden class=anchor aria-hidden=true href=#31-sbr>#</a></h2><p>就是记录 sql 语句在 bin-log 中, Mysql 5.1.4 及之前的版本都是使用的这种复制格式. 优点是只需要记录会修改数据的 sql 语句到 bin-log 中, 减少了 bin-log 日质量, 节约 I/O, 提高性能. 缺点是在某些情况下, 会导致主从节点中数据不一致 (比如 sleep(), now() 等).</p><h2 id=32-rbr>3.2 RBR<a hidden class=anchor aria-hidden=true href=#32-rbr>#</a></h2><p>mysql master 将 SQL 语句分解为基于 Row 更改的语句并记录在 bin-log 中, 也就是只记录哪条数据被修改了, 修改成什么样. 优点是不会出现某些特定情况下的存储过程、或者函数、或者 trigger 的调用或者触发无法被正确复制的问题. 缺点是会产生大量的日志, 尤其是修改 table 的时候会让日志暴增,同时增加 bin-log 同步时间. 也不能通过 bin-log 解析获取执行过的 sql 语句, 只能看到发生的 data 变更.</p><h2 id=33-mbr>3.3 MBR<a hidden class=anchor aria-hidden=true href=#33-mbr>#</a></h2><p>MySQL NDB cluster 7.3 和 7.4 使用的 MBR. 是以上两种模式的混合, 对于一般的复制使用 STATEMENT 模式保存到 bin-log, 对于 STATEMENT 模式无法复制的操作则使用 ROW 模式来保存, MySQL 会根据执行的 SQL 语句选择日志保存方式.</p><h1 id=4-gtid-复制>4 GTID 复制<a hidden class=anchor aria-hidden=true href=#4-gtid-复制>#</a></h1><p>在原来基于日志的复制中, slave 需要告知 master 要从哪个偏移量进行增量同步, 如果指定错误会造成数据的遗漏, 从而造成数据的不一致.</p><p>而基于 GTID 的复制中, slave 会告知 master 已经执行的事务的 GTID 的值, 然后 master 会将所有未执行的事务的 GTID 的列表返回给 slave. 并且可以保证同一个事务只在指定的 slave 执行一次. 通过全局的事务 ID 确定 slave 要执行的事务的方式代替了以前需要用 binlog 和 pos 点确定 slave 要执行的事务的方式.</p><p>GTID 是由 server_uuid 和事物 id 组成, 格式为: GTID=server_uuid:transaction_id. server_uuid 是在数据库启动过程中自动生成, 每台机器的 server-uuid 不一样. uuid 存放在数据目录的 auto.cnf 文件中，而 transaction_id 就是事务提交时系统顺序分配的一个不会重复的序列号</p><p>master 更新数据时, 会在事务前产生 GTID, 一起记录到 binlog 日志中. slave 的 IO 线程将变更的 binlog 写入到本地的 relaylog 中. SQL 线程从 relaylog 中获取 GTID, 然后对比本地 binlog 是否有记录 (所以 slave 必须要开启 binlog, 并且将 <code>log_slave_updates</code> 设置为 ON). 如果有记录，说明该 GTID 的事务已经执行, slave 会忽略. 如果没有记录, slave 就会从 relaylog 中执行该 GTID 的事务, 并记录到 binlog. 在解析过程中会判断是否有主键, 如果没有就用二级索引, 如果有就用全部扫描.</p><h1 id=5-并行复制>5 并行复制<a hidden class=anchor aria-hidden=true href=#5-并行复制>#</a></h1><p>master 大多数情况下都是多线程多客户端去写, 而 slave 只有一个 SQL 线程进行写, 无法避免地会出现主从复制的延迟问题, 并行复制可以指定线程数量, 从而提高 slave 写的速度.</p><p>在 mysql 5.6 版本之后引入了并行复制的概念</p><p><img loading=lazy src=https://image.lvbibir.cn/blog/935163-20210702004720791-198956831.png alt=img></p><p>通过上图我们可以发现其实所谓的并行复制, 就是在中间添加了一个分发的环节, 也就是说原来的 SQL 线程变成了现在的 coordinator 组件, 当 relaylog 日志更新后, coordinator 负责读取日志信息以及分发事务, 真正的执行过程是放在了 worker 线程上, 由多个线程并行的去执行.</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#5bc4bf>#</span> <span style=color:#ef6155>查看并行的</span>slave的线程的个数<span style=color:#ef6155>，默认是</span><span style=color:#f99b15>0</span>.<span style=color:#ef6155>表示单线程</span>
</span></span><span style=display:flex><span><span style=color:#815ba4>show</span> <span style=color:#815ba4>global</span> variables <span style=color:#815ba4>like</span> <span style=color:#48b685>&#39;slave_parallel_workers&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#5bc4bf>#</span> <span style=color:#ef6155>根据实际情况保证开启多少线程</span>
</span></span><span style=display:flex><span><span style=color:#815ba4>set</span> <span style=color:#815ba4>global</span> slave_parallel_workers <span style=color:#5bc4bf>=</span> <span style=color:#f99b15>4</span>;
</span></span><span style=display:flex><span><span style=color:#5bc4bf>#</span> <span style=color:#ef6155>设置并发复制的方式，默认是一个线程处理一个库，值为</span><span style=color:#815ba4>database</span>
</span></span><span style=display:flex><span><span style=color:#815ba4>show</span> <span style=color:#815ba4>global</span> variables <span style=color:#815ba4>like</span> <span style=color:#48b685>&#39;%slave_parallel_type%&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#5bc4bf>#</span> <span style=color:#ef6155>停止</span>slave
</span></span><span style=display:flex><span>stop slave;
</span></span><span style=display:flex><span><span style=color:#5bc4bf>#</span> <span style=color:#ef6155>设置属性值</span>
</span></span><span style=display:flex><span><span style=color:#815ba4>set</span> <span style=color:#815ba4>global</span> slave_parallel_type<span style=color:#5bc4bf>=</span><span style=color:#48b685>&#39;logical_check&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#5bc4bf>#</span> <span style=color:#ef6155>开启</span>slave
</span></span><span style=display:flex><span><span style=color:#815ba4>start</span> slave
</span></span><span style=display:flex><span><span style=color:#5bc4bf>#</span> <span style=color:#ef6155>查看线程数</span>
</span></span><span style=display:flex><span><span style=color:#815ba4>show</span> <span style=color:#815ba4>full</span> processlist;
</span></span></code></pre></div><p>以上</p></div><div class=post-reward><div style=padding:0;margin:0;width:100%;font-size:16px;text-align:center><div id=QR style=opacity:0><div id=wechat style=display:inline-block><a class=fancybox rel=group><img id=wechat_qr src=https://www.lvbibir.cn/img/wechat_pay.png alt=wechat_pay></a><p>微信</p></div><div id=alipay style=display:inline-block><a class=fancybox rel=group><img id=alipay_qr src=https://www.lvbibir.cn/img/alipay.png alt=alipay></a><p>支付宝</p></div></div><button id=rewardButton onclick='var qr=document.getElementById("QR");qr.style.opacity==="0"?qr.style.opacity="1":qr.style.opacity="0"'>
<span>🧧 鼓励</span></button></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://www.lvbibir.cn/en/posts/tech/network-priority/><span class=title>« 上一页</span><br><span>windows & linux 多网卡时设置默认路由以及添加静态路由</span>
</a><a class=next href=https://www.lvbibir.cn/en/posts/tech/mysql-1-deploy/><span class=title>下一页 »</span><br><span>mysql (一) 部署</span></a></nav></footer></div><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://cdn.staticfile.org/twikoo/1.6.15/twikoo.all.min.js></script><script>twikoo.init({envId:"https://twikoo.lvbibir.cn/",el:"#tcomment",lang:"zh-CN",path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><a href=https://gohugo.io/ target=_blank><img style=display:unset src=https://image.lvbibir.cn/blog/frame-hugo-blue.svg>
</a><a href=https://github.com/adityatelange/hugo-PaperMod target=_blank><img style=display:unset src=https://image.lvbibir.cn/blog/theme-papermod-lightgrey.svg>
</a><a href=https://cn.aliyun.com/ target=_blank><img style=display:unset src=https://image.lvbibir.cn/blog/图床-阿里云-orange.svg></a><br><span id=runtime_span></span>
<script type=text/javascript>function show_runtime(){window.setTimeout("show_runtime()",1e3),X=new Date("7/13/2021 1:00:00"),Y=new Date,T=Y.getTime()-X.getTime(),M=24*60*60*1e3,a=T/M,A=Math.floor(a),b=(a-A)*24,B=Math.floor(b),c=(b-B)*60,C=Math.floor((b-B)*60),D=Math.floor((c-C)*60),runtime_span.innerHTML="网站已运行"+A+"天"+B+"小时"+C+"分"+D+"秒"}show_runtime()</script>|
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container>总访客数: <span id=busuanzi_value_site_uv></span>
|
总访问量: <span id=busuanzi_value_site_pv></span></span><br><a href=https://beian.miit.gov.cn/ target=_blank style="border-bottom:1px solid">京ICP备2021023168号-1</a>&nbsp;
|
<span>Copyright
&copy;
2020-2024
<a href=https://www.lvbibir.cn/en/ style="border-bottom:1px solid">lvbibir's Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>400||document.documentElement.scrollTop>400?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="📄复制";function c(){t.innerText="👌🏻已复制!",setTimeout(()=>{t.innerText="📄复制"},2e3)}t.addEventListener("click",t=>{const n=document.createRange();n.selectNodeContents(e);const s=window.getSelection();s.removeAllRanges(),s.addRange(n);try{document.execCommand("copy"),c()}catch{}s.removeRange(n)});let l=e.className.replaceAll("language-",""),n=document.createElement("div"),i=document.createElement("div"),a=document.createElement("div"),r=document.createElement("div"),o=document.createElement("div");o.innerText=l,n.setAttribute("class","mac-tool"),i.setAttribute("class","mac bb1"),a.setAttribute("class","mac bb2"),r.setAttribute("class","mac bb3"),o.setAttribute("class","language-type"),n.appendChild(i),n.appendChild(a),n.appendChild(r),n.appendChild(o),s.classList.contains("highlight")?(s.appendChild(t),s.appendChild(n)):s.parentNode.firstChild===s||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName==="TABLE"?(e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t),s.appendChild(n)):(e.parentNode.appendChild(t),s.appendChild(n)))})</script></body></html>