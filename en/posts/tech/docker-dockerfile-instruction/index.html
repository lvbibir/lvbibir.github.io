<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>docker | dockerfile指令详解 | lvbibir's Blog</title><meta name=keywords content="docker,dockerfile"><meta name=description content="前言 Dockerfile用于构建docker镜像, 实际上就是把在linux下的命令操作写到了Dockerfile中, 通过Dockerfile去执行设置好的操作命令, 保证通过Dockerfile的构建镜像是一致的. Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，"><meta name=author content="作者:&nbsp;lvbibir"><link rel=canonical href=https://www.lvbibir.cn/en/posts/tech/docker-dockerfile-instruction/><link crossorigin=anonymous href=/assets/css/stylesheet.ea2d3aa74caabd1c227305342e99c488a04870896b2f729dec906b90f7870787.css integrity="sha256-6i06p0yqvRwicwU0LpnEiKBIcIlrL3Kd7JBrkPeHB4c=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.lvbibir.cn/img/avatar.gif><link rel=icon type=image/png sizes=16x16 href=https://www.lvbibir.cn/img/avatar.gif><link rel=icon type=image/png sizes=32x32 href=https://www.lvbibir.cn/img/avatar.gif><link rel=apple-touch-icon href=https://www.lvbibir.cn/img/avatar.gif><link rel=mask-icon href=https://www.lvbibir.cn/img/avatar.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="docker | dockerfile指令详解"><meta property="og:description" content="前言 Dockerfile用于构建docker镜像, 实际上就是把在linux下的命令操作写到了Dockerfile中, 通过Dockerfile去执行设置好的操作命令, 保证通过Dockerfile的构建镜像是一致的. Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，"><meta property="og:type" content="article"><meta property="og:url" content="https://www.lvbibir.cn/en/posts/tech/docker-dockerfile-instruction/"><meta property="og:image" content="https://image.lvbibir.cn/blog/docker.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-09T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-11T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://image.lvbibir.cn/blog/docker.png"><meta name=twitter:title content="docker | dockerfile指令详解"><meta name=twitter:description content="前言 Dockerfile用于构建docker镜像, 实际上就是把在linux下的命令操作写到了Dockerfile中, 通过Dockerfile去执行设置好的操作命令, 保证通过Dockerfile的构建镜像是一致的. Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"docker | dockerfile指令详解","item":"https://www.lvbibir.cn/en/posts/tech/docker-dockerfile-instruction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"docker | dockerfile指令详解","name":"docker | dockerfile指令详解","description":"前言 Dockerfile用于构建docker镜像, 实际上就是把在linux下的命令操作写到了Dockerfile中, 通过Dockerfile去执行设置好的操作命令, 保证通过Dockerfile的构建镜像是一致的. Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，","keywords":["docker","dockerfile"],"articleBody":"前言 Dockerfile用于构建docker镜像, 实际上就是把在linux下的命令操作写到了Dockerfile中, 通过Dockerfile去执行设置好的操作命令, 保证通过Dockerfile的构建镜像是一致的.\nDockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。\n参考内容：\nhttps://yeasy.gitbook.io/docker_practice/image/dockerfile FROM 指定基础镜像 命令格式\nFROM IMAGE[:TAG][@DIGEST] 我们可以用任意已存在的镜像为基础构建我们的自定义镜像\n比如:\n系统镜像: centos, ubuntu, debian, alpine\n应用镜像: nginx, redis, mongo, mysql, httpd\n运行环境镜像: php, java, golang\n工具镜像: busybox\n示例\n# tag 默认使用 latest FROM alpine # 指定 tag FROM alpine:3.17.3 # 指定 digest FROM alpine@sha256:b6ca290b6b4cdcca5b3db3ffa338ee0285c11744b4a6abaa9627746ee3291d8d # 同时指定 tag 和 digest FROM alpine:3.17.3@sha256:b6ca290b6b4cdcca5b3db3ffa338ee0285c11744b4a6abaa9627746ee3291d8d 除了选择现有镜像为基础镜像外，Docker还存在一个特殊的镜像，名为 scratch。这个镜像无法从别处拉取, 可以理解为是Docker自 1.5.0 版本开始的自带镜像, 它仅包含一个空的文件系统.\nscratch镜像一般用于构建基础镜像, 比如官方镜像Ubuntu\nCOPY 复制文件 格式:\nCOPY [--chown=:] \u003c源路径1\u003e [源路径2] ... \u003c目标路径\u003e COPY [--chown=:] [\"\u003c源路径1\u003e\", \"[源路径2]\", ..., \"\u003c目标路径\u003e\"] COPY 指令将从构建上下文目录中 \u003c源路径\u003e 的文件/目录复制到新的镜像层内的 \u003c目标路径\u003e 位置.\n\u003c源路径\u003e 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：\nCOPY hom* /mydir/ COPY hom?.txt /mydir/ \u003c目标路径\u003e 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。\n此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。\n在使用该指令的时候还可以加上 --chown=: 选项来改变文件的所属用户及所属组。\nCOPY --chown=55:mygroup files* /mydir/ COPY --chown=bin files* /mydir/ COPY --chown=1 files* /mydir/ COPY --chown=10:11 files* /mydir/ ADD 更高级的复制文件 ADD 指令和 COPY 的格式和性质基本一致。同样支持 --chown=: 指令修改属主和属组。\n但是在 COPY 基础上增加了一些功能:\n\u003c源路径\u003e 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 \u003c目标路径\u003e 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整. 如果 \u003c源路径\u003e 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 \u003c目标路径\u003e 去。 在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。\n另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。\nRUN 执行命令 格式:\nshell格式:RUN [command] ..., 等价于在linux中执行/bin/sh -c \"command parameter1 parameter2 ...\"\nRUN ls -l exec格式:RUN [\"command\", \"parameter1\", \"parameter2\"...], 不会通过shell执行, 所以像$HOME这样的变量就无法获取.\nRUN [\"ls\", \"-l\"] RUN [\"/bin/sh\", \"-c\", \"ls -l\"] # 可以获取环境变量 RUN指令用于指定构建镜像时执行的命令, Dockerfile允许多个RUN指令, 并且每个RUN指令都会创建一个镜像层.\nRUN指令一般用于安装配置软件包等操作, 为避免镜像层数过多, 一般RUN指令使用shell格式且使用换行符来执行多个命令，且尽量将 RUN 指令产生的附属物删除以缩小镜像大小\n如下示例\nFROM debian:stretch RUN set -x; buildDeps='gcc libc6-dev make wget' \\ \u0026\u0026 apt-get update \\ \u0026\u0026 apt-get install -y $buildDeps \\ \u0026\u0026 wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" \\ \u0026\u0026 mkdir -p /usr/src/redis \\ \u0026\u0026 tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ \u0026\u0026 make -C /usr/src/redis \\ \u0026\u0026 make -C /usr/src/redis install \\ \u0026\u0026 rm -rf /var/lib/apt/lists/* \\ \u0026\u0026 rm redis.tar.gz \\ \u0026\u0026 rm -r /usr/src/redis \\ \u0026\u0026 apt-get purge -y --auto-remove $buildDeps CMD 容器启动命令 CMD 指令的格式和 RUN 相似，也是两种格式：\nshell 格式：CMD [command] exec 格式：CMD [\"command\", \"\", \"parameter2\", ...] 参数列表格式：CMD [\"参数1\", \"参数2\"...]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。 CMD 指令用于设置容器启动时 默认执行 的指令，一般会设置为应用程序的启动脚本或者工具镜像的bash，设置了多条CMD指令时，只有最后一条 CMD 会被执行。\n在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，会输出系统版本信息。\n在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 \"，而不要使用单引号。\n例如一般nginx容器的CMD指令:\nCMD [\"nginx\", \"-g\", \"daemon off;\"] ENTRYPOINT 入口点 ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。\nshell 格式：ENTRYPOINT [command] exec 格式：ENTRYPOINT [\"command\", \"\", \"\", ...] ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。\n当指定了 ENTRYPOINT 且使用的是 exec 格式时，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：\nENTRYPOINT [\"command\", \"\", \"\", \"CMD\"] 以下示例将展示 CMD 指令作为参数传给 ENTRYPOINT 的场景\n场景一：我们自己构建了一个用于查看外网 ip 和归属地的镜像\nFROM alpine RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories \\ \u0026\u0026 apk --update add curl CMD [ \"-s\" ] ENTRYPOINT [ \"curl\", \"http://myip.ipip.net\" ] 构建\ndocker build -t busybox-curl . 以两种方式运行\n# 容器中实际执行的指令为 curl http://myip.ipip.net -s [root@lvbibir learn]# docker run -it --rm busybox-curl 当前 IP：101.201.150.47 来自于：中国 北京 北京 阿里云 # 容器中实际执行的指令为 curl http://myip.ipip.net -i [root@lvbibir learn]# docker run -it --rm busybox-curl -i HTTP/1.1 200 OK Date: Mon, 10 Apr 2023 03:21:59 GMT Content-Type: text/plain; charset=utf-8 Content-Length: 72 Connection: keep-alive Node: ipip-myip5 X-Cache: BYPASS X-Request-Id: e309720b9197e8b94cec18b409c69d1d Server: WAF Connection: close Accept-Ranges: bytes 当前 IP：101.201.150.47 来自于：中国 北京 北京 阿里云 场景二：应用运行前的准备工作\n启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。\n比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。\n此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。\n这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 ）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的：\nFROM alpine:3.4 ... RUN addgroup -S redis \u0026\u0026 adduser -S -G redis redis ... ENTRYPOINT [\"docker-entrypoint.sh\"] EXPOSE 6379 CMD [ \"redis-server\" ] 可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh 脚本：\n#!/bin/sh ... # allow the container to be started with `--user` if [ \"$1\" = 'redis-server' -a \"$(id -u)\" = '0' ]; then find . \\! -user redis -exec chown redis '{}' + exec gosu redis \"$0\" \"$@\" fi exec \"$@\" 该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如：\n[root@lvbibir learn]# docker run -it redis id uid=0(root) gid=0(root) groups=0(root) ENV 设置环境变量 格式有两种：\nENV ENV = =... ENV 用于设置环境变量，既可以在 Dockerfile 中调用，也可以在构建完的容器运行时中使用。\n支持的指令： ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN\n下面这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。\nENV VERSION=1.0 DEBUG=on \\ NAME=\"Happy Feet\" 示例\nFROM alpine ENV VERSION=1.0 \\ DEBUG=on \\ NAME=\"Happy Feet\" RUN echo \"name: ${NAME}\" \u003e /test \\ \u0026\u0026 echo \"version: ${VERSION}\" \u003e\u003e /test 构建\n[root@lvbibir learn]# docker build -t demo-env . 构建时调用了环境变量\n[root@lvbibir learn]# docker run -it --rm demo-env cat /test name: Happy Feet version: 1.0 构建后的容器运行时中调用，这里需要使用 /bin/sh -c 的方式，不然无法读取变量。且对 $ 进行转义，不然读取的将会是宿主机的变量\n[root@lvbibir learn]# docker run -it --rm demo-env /bin/sh -c \"echo \\${DEBUG}\" on ARG 构建参数 构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。\nDockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 --build-arg \u003c参数名\u003e=\u003c值\u003e 来覆盖。\n灵活的使用 ARG 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。\nARG 指令有生效范围，如果在 FROM 指令之前指定，那么只能用于 FROM 指令中，FROM 指令可以是多个\nARG DOCKER_USERNAME=library FROM ${DOCKER_USERNAME}/alpine RUN set -x ; echo ${DOCKER_USERNAME} 使用上述 Dockerfile 会发现无法输出 ${DOCKER_USERNAME} 变量的值，要想正常输出，你必须在 FROM 之后再次指定 ARG，如下示例\n# 只在 FROM 中生效 ARG DOCKER_USERNAME=library FROM ${DOCKER_USERNAME}/alpine # 要想在 FROM 之后使用，必须再次指定 ARG DOCKER_USERNAME=library RUN set -x ; echo ${DOCKER_USERNAME} 如下示例，变量将会在每个 FROM 指令中生效\n# 这个变量在每个 FROM 中都生效 ARG DOCKER_USERNAME=library FROM ${DOCKER_USERNAME}/alpine RUN set -x ; echo 1 FROM ${DOCKER_USERNAME}/alpine RUN set -x ; echo 2 如下示例，对于在各个阶段中使用的变量都必须在每个阶段分别指定\nARG DOCKER_USERNAME=library FROM ${DOCKER_USERNAME}/alpine # 在FROM 之后使用变量，必须在每个阶段分别指定 ARG DOCKER_USERNAME=library RUN set -x ; echo ${DOCKER_USERNAME} FROM ${DOCKER_USERNAME}/alpine # 在FROM 之后使用变量，必须在每个阶段分别指定 ARG DOCKER_USERNAME=library RUN set -x ; echo ${DOCKER_USERNAME} VOLUME 定义匿名卷 格式为：\nVOLUME [\"\u003c路径1\u003e\", \"\u003c路径2\u003e\"...] VOLUME \u003c路径\u003e 容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。\n为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据，从而保证了容器存储层的无状态化。\nVOLUME 创建的匿名卷会挂载到系统 /var/lib/docker/volumes//\u003c_VOLUME\u003e 目录下，且不会随着容器删除而删除，需要手动删除\n如下示例\nFROM alpine VOLUME /data 构建运行\n[root@lvbibir learn]# docker build -t demo-volume . [root@lvbibir learn]# docker run -itd --name=demo-volume demo-volume [root@lvbibir learn]# docker exec -it demo-volume ls -ld /data drwxr-xr-x 2 root root 4096 Apr 10 05:24 /data 查看挂载目录\n[root@lvbibir learn]# docker inspect --format='{{json .Mounts}}' demo-volume | python -m json.tool [ { \"Destination\": \"/data\", \"Driver\": \"local\", \"Mode\": \"\", \"Name\": \"49cf915dd297292e3d0e4b2c7a66ead6875cfb0dbd010de15189040ab1158b3b\", \"Propagation\": \"\", \"RW\": true, \"Source\": \"/var/lib/docker/volumes/49cf915dd297292e3d0e4b2c7a66ead6875cfb0dbd010de15189040ab1158b3b/_data\", \"Type\": \"volume\" } ] 如下示例，运行容器时，可以指定 -v 参数将目录挂载到指定位置\n[root@lvbibir learn]# docker run -itd -v /mydata:/data --name demo-volume-2 demo-volume [root@lvbibir learn]# docker inspect --format='{{json .Mounts}}' demo-volume-2 | python -m json.tool [ { \"Destination\": \"/data\", \"Mode\": \"\", \"Propagation\": \"rprivate\", \"RW\": true, \"Source\": \"/mydata\", \"Type\": \"bind\" } ] EXPOSE 暴露端口 格式为 EXPOSE \u003c端口1\u003e [端口2] ...\nEXPOSE 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务\n在 Dockerfile 中写入这样的声明有两个好处：\n一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射； 另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 要将 EXPOSE 和在运行时使用 -p \u003c宿主端口\u003e:\u003c容器端口\u003e 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。\nWORKDIR 指定工作目录 格式为 WORKDIR \u003c路径\u003e\n使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录\n如下示例，是一个常见的错误，world.txt 最终会在 /app 目录下，而不是期望的 /app/demo 目录\nWORKDIR /app RUN mkdir demo \u0026\u0026 cd demo RUN echo \"hello\" \u003e world.txt 上述需求可以进行如下优化，推荐使用第二种写法\nWORKDIR /app/demo RUN echo \"hello\" \u003e world.txt # 或者 WORKDIR /app RUN mkdir demo \\ \u0026\u0026 echo \"hello\" \u003e demo/world.txt # 或者 WORKDIR /app RUN mkdir demo \\ \u0026\u0026 cd demo \\ \u0026\u0026 echo \"hello\" \u003e demo/world.txt 如果你的 WORKDIR 指令使用的相对路径，那么所切换的路径与之前的 WORKDIR 有关\n如下示例，pwd 的输出将会是 /a/b/c\nWORKDIR /a WORKDIR b WORKDIR c RUN pwd USER 指定当前用户 格式：USER \u003c用户名\u003e[:\u003c用户组\u003e]\nUSER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。\n注意，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。\nRUN groupadd -r redis \u0026\u0026 useradd -r -g redis redis USER redis RUN [ \"redis-server\" ] 如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu\n不过更推荐的还是 上文 中提到过的通过 ENTRYPOINT 脚本的方式\n使用 gosu 示例\n# 建立 redis 用户，并使用 gosu 换另一个用户执行命令 RUN groupadd -r redis \u0026\u0026 useradd -r -g redis redis # 下载 gosu RUN wget -O /usr/local/bin/gosu \"https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64\" \\ \u0026\u0026 chmod +x /usr/local/bin/gosu \\ \u0026\u0026 gosu nobody true # 设置 CMD，并以另外的用户执行 CMD [ \"exec\", \"gosu\", \"redis\", \"redis-server\" ] HEALTHCHECK 健康检查 格式：\nHEALTHCHECK [选项] CMD \u003c命令\u003e：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。\n在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。\nHEALTHCHECK 支持下列选项：\n--interval=\u003c间隔\u003e：两次健康检查的间隔，默认为 30 秒； --timeout=\u003c时长\u003e：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒； --retries=\u003c次数\u003e：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。 和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。\n在 HEALTHCHECK [选项] CMD 后面的命令，格式和 ENTRYPOINT 一样，分为 shell 格式，和 exec 格式。命令的返回值决定了该次健康检查的成功与否：\n0：成功； 1：失败； 2：保留，不要使用这个值。 如下示例，假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断\nFROM nginx HEALTHCHECK --interval=5s --timeout=3s --retries=3\\ CMD curl -fs http://localhost/ || exit 1 构建运行\n[root@lvbibir learn]# docker build -t myweb . [root@lvbibir learn]# docker run -d --name demo-myweb -p 800:80 myweb # 此时是 starting 状态 [root@lvbibir learn]# docker ps | grep myweb e6f585df60a6 myweb \"/docker-entrypoint.…\" About a minute ago Up 2 seconds (health: starting) 0.0.0.0:800-\u003e80/tcp demo-myweb # 等待几秒变为 healthy 状态 [root@lvbibir learn]# docker ps | grep myweb e6f585df60a6 myweb \"/docker-entrypoint.…\" 2 minutes ago Up About a minute (healthy) 0.0.0.0:800-\u003e80/tcp demo-myweb 删除 index.html 文件模拟故障\n[root@lvbibir learn]# docker exec -it demo-myweb rm -f /usr/share/nginx/html/index.html # 状态变为unhealthy [root@lvbibir learn]# docker ps | grep myweb e6f585df60a6 myweb \"/docker-entrypoint.…\" 6 minutes ago Up 5 minutes (unhealthy) 0.0.0.0:800-\u003e80/tcp demo-myweb 为了帮助排障，健康检查命令的输出（包括 stdout 以及 stderr）都会被存储于健康状态里，可以用 docker inspect 来查看。\n[root@lvbibir learn]# docker inspect --format '{{json .State.Health}}' demo-myweb | python -m json.tool { \"FailingStreak\": 25, \"Log\": [ { \"End\": \"2023-04-10T14:41:51.393698555+08:00\", \"ExitCode\": 1, \"Output\": \"\", \"Start\": \"2023-04-10T14:41:51.285647058+08:00\" }, { \"End\": \"2023-04-10T14:41:56.504282619+08:00\", \"ExitCode\": 1, \"Output\": \"\", \"Start\": \"2023-04-10T14:41:56.401745529+08:00\" }, ........... ], \"Status\": \"unhealthy\" } 恢复文件\n[root@lvbibir learn]# docker exec -it demo-myweb /bin/bash root@e6f585df60a6:/# echo test \u003e /usr/share/nginx/html/index.html root@e6f585df60a6:/# exit [root@lvbibir learn]# docker inspect --format '{{json .State.Health}}' demo-myweb | python -m json.tool { \"FailingStreak\": 0, \"Log\": [ { \"End\": \"2023-04-10T14:48:30.482498808+08:00\", \"ExitCode\": 0, \"Output\": \"test\\n\", \"Start\": \"2023-04-10T14:48:30.378197999+08:00\" }, { \"End\": \"2023-04-10T14:48:35.599150547+08:00\", \"ExitCode\": 0, \"Output\": \"test\\n\", \"Start\": \"2023-04-10T14:48:35.490433323+08:00\" }, ....... ], \"Status\": \"healthy\" } ONBUILD 为他人作嫁衣裳 格式：ONBUILD \u003c其它指令\u003e。\nONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。\nDockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。\n假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里。在拿到程序代码后，需要先进行 npm install 才可以获得所有需要的依赖。然后就可以通过 npm start 来启动应用。因此，一般来说会这样写 Dockerfile：\nFROM node:slim WORKDIR /app COPY ./package.json /app RUN [ \"npm\", \"install\" ] COPY . /app/ CMD [ \"npm\", \"start\" ] 把这个 Dockerfile 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 Dockerfile 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。\n如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 Dockerfile 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 Dockerfile，而第二个项目的 Dockerfile 就会被自动修复。\n那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 Dockerfile 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。\n基础镜像(my-node) Dockerfile\nFROM node:slim WORKDIR /app CMD [ \"npm\", \"start\" ] 应用镜像(my-app1) Dockerfile\nFROM my-node COPY ./package.json /app RUN [ \"npm\", \"install\" ] COPY . /app/ 基础镜像变化后，各个项目都用这个 Dockerfile 重新构建镜像，会继承基础镜像的更新。\n那么，问题解决了么？没有。准确说，只解决了一半。如果这个 Dockerfile 里面有些东西需要调整呢？比如 npm install 都需要加一些参数，那怎么办？这一行 RUN 是不可能放入基础镜像的，因为涉及到了当前项目的 ./package.json，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 Dockerfile 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。\nONBUILD 可以解决这个问题。让我们用 ONBUILD 重新写一下基础镜像的 Dockerfile:\nFROM node:slim WORKDIR /app ONBUILD COPY ./package.json /app ONBUILD RUN [ \"npm\", \"install\" ] ONBUILD COPY . /app/ CMD [ \"npm\", \"start\" ] 应用镜像 Dcokerfile\nFROM my-node 是的，只有这么一行。当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，之前基础镜像的那三行 ONBUILD 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 npm install，生成应用镜像。\nLABEL 为镜像添加元数据 LABEL 指令用来给镜像以键值对的形式添加一些元数据（metadata）。\nLABEL = = = ... 我们还可以用一些标签来申明镜像的作者、文档地址等：\nLABEL org.opencontainers.image.authors=\"yeasy\" LABEL org.opencontainers.image.documentation=\"https://yeasy.gitbooks.io\" 具体可以参考 https://github.com/opencontainers/image-spec/blob/master/annotations.md\nSHELL 指定shell 格式：SHELL [\"executable\", \"parameters\"]\nSHELL 指令可以指定 RUN ENTRYPOINT CMD 指令的 shell，Linux 中默认为 `[\"/bin/sh\", “-c”]\n如下示例，两个 RUN 运行同一命令，第二个 RUN 运行的命令会打印出每条命令并当遇到错误时退出。\nSHELL [\"/bin/sh\", \"-c\"] RUN lll ; ls SHELL [\"/bin/sh\", \"-cex\"] RUN lll ; ls 如下示例，当 ENTRYPOINT CMD 以 shell 格式指定时，SHELL 指令所指定的 shell 也会成为这两个指令的 shell\nSHELL [\"/bin/sh\", \"-cex\"] # /bin/sh -cex \"nginx\" ENTRYPOINT nginx # /bin/sh -cex \"nginx\" CMD nginx ","wordCount":"7279","inLanguage":"en","image":"https://image.lvbibir.cn/blog/docker.png","datePublished":"2023-04-09T00:00:00Z","dateModified":"2023-04-11T00:00:00Z","author":{"@type":"Person","name":"lvbibir"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.lvbibir.cn/en/posts/tech/docker-dockerfile-instruction/"},"publisher":{"@type":"Organization","name":"lvbibir's Blog","logo":{"@type":"ImageObject","url":"https://www.lvbibir.cn/img/avatar.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.lvbibir.cn/en/ accesskey=h title="lvbibir's Blog (Alt + H)"><img src=https://www.lvbibir.cn/img/avatar.gif alt aria-label=logo height=35>lvbibir's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li class=menu-item><a href=https://www.lvbibir.cn/en/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li class=menu-item><a href=https://www.lvbibir.cn/en/posts title="📚 文章"><span>📚 文章</span></a></li><li class=menu-item><a href=https://www.lvbibir.cn/en/archives title="📈 归档"><span>📈 归档</span></a></li><li class=menu-item><a href=https://www.lvbibir.cn/en/talk title="💬 说说"><span>💬 说说</span></a></li><li class=menu-item><a href=https://www.lvbibir.cn/en/links title="🤝 友链"><span>🤝 友链</span></a></li></ul></nav></header><main class="main page"><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://www.lvbibir.cn/en/>主页</a></div><h1 class=post-title>docker | dockerfile指令详解</h1><div class=post-meta>创建:&nbsp;<span title='2023-04-09 00:00:00 +0000 UTC'>2023-04-09</span>&nbsp;|&nbsp;更新:&nbsp;2023-04-11&nbsp;|&nbsp;字数:&nbsp;7279字&nbsp;|&nbsp;作者:&nbsp;lvbibir
|&nbsp;标签:&nbsp;<ul class=post-tags-meta><a href=https://www.lvbibir.cn/en/tags/docker/>docker</a></ul><span id=busuanzi_container_page_pv>&nbsp;|&nbsp;访问:&nbsp;<span id=busuanzi_value_page_pv></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>文章目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#from-%e6%8c%87%e5%ae%9a%e5%9f%ba%e7%a1%80%e9%95%9c%e5%83%8f aria-label="FROM 指定基础镜像">FROM 指定基础镜像</a></li><li><a href=#copy-%e5%a4%8d%e5%88%b6%e6%96%87%e4%bb%b6 aria-label="COPY 复制文件">COPY 复制文件</a></li><li><a href=#add-%e6%9b%b4%e9%ab%98%e7%ba%a7%e7%9a%84%e5%a4%8d%e5%88%b6%e6%96%87%e4%bb%b6 aria-label="ADD 更高级的复制文件">ADD 更高级的复制文件</a></li><li><a href=#run-%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4 aria-label="RUN 执行命令">RUN 执行命令</a></li><li><a href=#cmd-%e5%ae%b9%e5%99%a8%e5%90%af%e5%8a%a8%e5%91%bd%e4%bb%a4 aria-label="CMD 容器启动命令">CMD 容器启动命令</a></li><li><a href=#entrypoint-%e5%85%a5%e5%8f%a3%e7%82%b9 aria-label="ENTRYPOINT 入口点">ENTRYPOINT 入口点</a></li><li><a href=#env-%e8%ae%be%e7%bd%ae%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f aria-label="ENV 设置环境变量">ENV 设置环境变量</a></li><li><a href=#arg-%e6%9e%84%e5%bb%ba%e5%8f%82%e6%95%b0 aria-label="ARG 构建参数">ARG 构建参数</a></li><li><a href=#volume-%e5%ae%9a%e4%b9%89%e5%8c%bf%e5%90%8d%e5%8d%b7 aria-label="VOLUME 定义匿名卷">VOLUME 定义匿名卷</a></li><li><a href=#expose-%e6%9a%b4%e9%9c%b2%e7%ab%af%e5%8f%a3 aria-label="EXPOSE 暴露端口">EXPOSE 暴露端口</a></li><li><a href=#workdir-%e6%8c%87%e5%ae%9a%e5%b7%a5%e4%bd%9c%e7%9b%ae%e5%bd%95 aria-label="WORKDIR 指定工作目录">WORKDIR 指定工作目录</a></li><li><a href=#user-%e6%8c%87%e5%ae%9a%e5%bd%93%e5%89%8d%e7%94%a8%e6%88%b7 aria-label="USER 指定当前用户">USER 指定当前用户</a></li><li><a href=#healthcheck-%e5%81%a5%e5%ba%b7%e6%a3%80%e6%9f%a5 aria-label="HEALTHCHECK 健康检查">HEALTHCHECK 健康检查</a></li><li><a href=#onbuild-%e4%b8%ba%e4%bb%96%e4%ba%ba%e4%bd%9c%e5%ab%81%e8%a1%a3%e8%a3%b3 aria-label="ONBUILD 为他人作嫁衣裳">ONBUILD 为他人作嫁衣裳</a></li><li><a href=#label-%e4%b8%ba%e9%95%9c%e5%83%8f%e6%b7%bb%e5%8a%a0%e5%85%83%e6%95%b0%e6%8d%ae aria-label="LABEL 为镜像添加元数据">LABEL 为镜像添加元数据</a></li><li><a href=#shell-%e6%8c%87%e5%ae%9ashell aria-label="SHELL 指定shell">SHELL 指定shell</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>Dockerfile用于构建docker镜像, 实际上就是把在linux下的命令操作写到了Dockerfile中, 通过Dockerfile去执行设置好的操作命令, 保证通过Dockerfile的构建镜像是一致的.</p><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(<code>Instruction</code>)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>参考内容：</p><ul><li><a href=https://yeasy.gitbook.io/docker_practice/image/dockerfile target=_blank rel=noopener style=color:#42b983 ;>https://yeasy.gitbook.io/docker_practice/image/dockerfile</a></li></ul><h2 id=from-指定基础镜像>FROM 指定基础镜像<a hidden class=anchor aria-hidden=true href=#from-指定基础镜像>#</a></h2><p>命令格式</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> IMAGE[:TAG][@DIGEST]</span><span style=color:#ef6155>
</span></span></span></code></pre></div><p>我们可以用任意已存在的镜像为基础构建我们的自定义镜像</p><p>比如:</p><ul><li><p>系统镜像: <code>centos</code>, <code>ubuntu</code>, <code>debian</code>, <code>alpine</code></p></li><li><p>应用镜像: <code>nginx</code>, <code>redis</code>, <code>mongo</code>, <code>mysql</code>, <code>httpd</code></p></li><li><p>运行环境镜像: <code>php</code>, <code>java</code>, <code>golang</code></p></li><li><p>工具镜像: <code>busybox</code></p></li></ul><p>示例</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#776e71># tag 默认使用 latest </span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>FROM</span><span style=color:#48b685> alpine</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#776e71># 指定 tag</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>FROM</span><span style=color:#48b685> alpine:3.17.3</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#776e71># 指定 digest</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>FROM</span><span style=color:#48b685> alpine@sha256:b6ca290b6b4cdcca5b3db3ffa338ee0285c11744b4a6abaa9627746ee3291d8d</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#776e71># 同时指定 tag 和 digest</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>FROM</span><span style=color:#48b685> alpine:3.17.3@sha256:b6ca290b6b4cdcca5b3db3ffa338ee0285c11744b4a6abaa9627746ee3291d8d</span><span style=color:#ef6155>
</span></span></span></code></pre></div><p>除了选择现有镜像为基础镜像外，Docker还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像无法从别处拉取, 可以理解为是Docker自 <a href=https://github.com/moby/moby/pull/8827 target=_blank rel=noopener style=color:#42b983 ;>1.5.0</a> 版本开始的自带镜像, 它仅包含一个空的文件系统.</p><p>scratch镜像一般用于构建基础镜像, 比如官方镜像<code>Ubuntu</code></p><h2 id=copy-复制文件>COPY 复制文件<a hidden class=anchor aria-hidden=true href=#copy-复制文件>#</a></h2><p>格式:</p><ul><li><code>COPY [--chown=&lt;user>:&lt;group>] &lt;源路径1> [源路径2] ... &lt;目标路径></code></li><li><code>COPY [--chown=&lt;user>:&lt;group>] ["&lt;源路径1>", "[源路径2]", ..., "&lt;目标路径>"]</code></li></ul><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径></code> 的文件/目录复制到新的镜像层内的 <code>&lt;目标路径></code> 位置.</p><p><code>&lt;源路径></code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href=https://golang.org/pkg/path/filepath/#Match target=_blank rel=noopener style=color:#42b983 ;>filepath.Match</a> 规则，如：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>COPY</span> hom* /mydir/<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>COPY</span> hom?.txt /mydir/<span style=color:#ef6155>
</span></span></span></code></pre></div><p><code>&lt;目标路径></code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user>:&lt;group></code> 选项来改变文件的所属用户及所属组。</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>COPY</span> --chown<span style=color:#5bc4bf>=</span>55:mygroup files* /mydir/<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>COPY</span> --chown<span style=color:#5bc4bf>=</span>bin files* /mydir/<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>COPY</span> --chown<span style=color:#5bc4bf>=</span><span style=color:#f99b15>1</span> files* /mydir/<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>COPY</span> --chown<span style=color:#5bc4bf>=</span>10:11 files* /mydir/<span style=color:#ef6155>
</span></span></span></code></pre></div><h2 id=add-更高级的复制文件>ADD 更高级的复制文件<a hidden class=anchor aria-hidden=true href=#add-更高级的复制文件>#</a></h2><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。同样支持 <code>--chown=&lt;user>:&lt;group></code> 指令修改属主和属组。</p><p>但是在 <code>COPY</code> 基础上增加了一些功能:</p><ul><li><code>&lt;源路径></code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径></code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整.</li><li>如果 <code>&lt;源路径></code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径></code> 去。</li></ul><p>在 Docker 官方的 <a href>Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><h2 id=run-执行命令>RUN 执行命令<a hidden class=anchor aria-hidden=true href=#run-执行命令>#</a></h2><p>格式:</p><ul><li><p>shell格式:<code>RUN [command] &lt;parameter1> &lt;parameter2> ...</code>, 等价于在linux中执行<code>/bin/sh -c "command parameter1 parameter2 ..."</code></p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>RUN</span> ls -l<span style=color:#ef6155>
</span></span></span></code></pre></div></li><li><p>exec格式:<code>RUN ["command", "parameter1", "parameter2"...]</code>, 不会通过shell执行, 所以像<code>$HOME</code>这样的变量就无法获取.</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>RUN</span> <span style=color:#5bc4bf>[</span><span style=color:#48b685>&#34;ls&#34;</span>, <span style=color:#48b685>&#34;-l&#34;</span><span style=color:#5bc4bf>]</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> <span style=color:#5bc4bf>[</span><span style=color:#48b685>&#34;/bin/sh&#34;</span>, <span style=color:#48b685>&#34;-c&#34;</span>, <span style=color:#48b685>&#34;ls -l&#34;</span><span style=color:#5bc4bf>]</span> <span style=color:#776e71># 可以获取环境变量</span><span style=color:#ef6155>
</span></span></span></code></pre></div></li></ul><p>RUN指令用于指定构建镜像时执行的命令, Dockerfile允许多个RUN指令, 并且每个RUN指令都会创建一个镜像层.</p><p>RUN指令一般用于安装配置软件包等操作, 为避免镜像层数过多, 一般RUN指令使用shell格式且使用换行符来执行多个命令，且尽量将 <code>RUN</code> 指令产生的附属物删除以缩小镜像大小</p><p>如下示例</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> debian:stretch</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> set -x; <span style=color:#ef6155>buildDeps</span><span style=color:#5bc4bf>=</span><span style=color:#48b685>&#39;gcc libc6-dev make wget&#39;</span> <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> apt-get update <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> apt-get install -y <span style=color:#ef6155>$buildDeps</span> <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> wget -O redis.tar.gz <span style=color:#48b685>&#34;http://download.redis.io/releases/redis-5.0.3.tar.gz&#34;</span> <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> mkdir -p /usr/src/redis <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components<span style=color:#5bc4bf>=</span><span style=color:#f99b15>1</span> <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> make -C /usr/src/redis <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> make -C /usr/src/redis install <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> rm -rf /var/lib/apt/lists/* <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> rm redis.tar.gz <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> rm -r /usr/src/redis <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> apt-get purge -y --auto-remove <span style=color:#ef6155>$buildDeps</span><span style=color:#ef6155>
</span></span></span></code></pre></div><h2 id=cmd-容器启动命令>CMD 容器启动命令<a hidden class=anchor aria-hidden=true href=#cmd-容器启动命令>#</a></h2><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD [command] &lt;parameters></code></li><li><code>exec</code> 格式：<code>CMD ["command", "&lt;parameter1>", "parameter2", ...]</code></li><li>参数列表格式：<code>CMD ["参数1", "参数2"...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p><code>CMD</code> 指令用于设置容器启动时 <font color=red>默认执行</font> 的指令，一般会设置为应用程序的启动脚本或者工具镜像的<code>bash</code>，设置了多条<code>CMD</code>指令时，只有最后一条 <code>CMD</code> 会被执行。</p><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，会输出系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>"</code>，而不要使用单引号。</p><p>例如一般<code>nginx</code>容器的<code>CMD</code>指令:</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>CMD</span> [<span style=color:#48b685>&#34;nginx&#34;</span>, <span style=color:#48b685>&#34;-g&#34;</span>, <span style=color:#48b685>&#34;daemon off;&#34;</span>]<span style=color:#ef6155>
</span></span></span></code></pre></div><h2 id=entrypoint-入口点>ENTRYPOINT 入口点<a hidden class=anchor aria-hidden=true href=#entrypoint-入口点>#</a></h2><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><ul><li><code>shell</code> 格式：<code>ENTRYPOINT [command] &lt;parameters></code></li><li><code>exec</code> 格式：<code>ENTRYPOINT ["command", "&lt;parameter1>", "&lt;parameter2>", ...]</code></li></ul><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p><p>当指定了 <code>ENTRYPOINT</code> 且使用的是 <code>exec</code> 格式时，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>ENTRYPOINT</span> [<span style=color:#48b685>&#34;command&#34;</span>, <span style=color:#48b685>&#34;&lt;parameter1&gt;&#34;</span>, <span style=color:#48b685>&#34;&lt;parameter2&gt;&#34;</span>, <span style=color:#48b685>&#34;CMD&#34;</span>]<span style=color:#ef6155>
</span></span></span></code></pre></div><p>以下示例将展示 <code>CMD</code> 指令作为参数传给 <code>ENTRYPOINT</code> 的场景</p><p>场景一：我们自己构建了一个用于查看外网 ip 和归属地的镜像</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> alpine</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> sed -i <span style=color:#48b685>&#39;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#39;</span> /etc/apk/repositories <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> apk --update add curl<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>CMD</span> [ <span style=color:#48b685>&#34;-s&#34;</span> ]<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>ENTRYPOINT</span> [ <span style=color:#48b685>&#34;curl&#34;</span>, <span style=color:#48b685>&#34;http://myip.ipip.net&#34;</span> ]<span style=color:#ef6155>
</span></span></span></code></pre></div><p>构建</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker build -t busybox-curl .
</span></span></code></pre></div><p>以两种方式运行</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#776e71># 容器中实际执行的指令为 curl http://myip.ipip.net -s</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -it --rm busybox-curl</span>
</span></span><span style=display:flex><span>当前 IP：101.201.150.47  来自于：中国 北京 北京  阿里云
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#776e71># 容器中实际执行的指令为 curl http://myip.ipip.net -i</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -it --rm busybox-curl -i</span>
</span></span><span style=display:flex><span>HTTP/1.1 <span style=color:#f99b15>200</span> OK
</span></span><span style=display:flex><span>Date: Mon, <span style=color:#f99b15>10</span> Apr <span style=color:#f99b15>2023</span> 03:21:59 GMT
</span></span><span style=display:flex><span>Content-Type: text/plain; <span style=color:#ef6155>charset</span><span style=color:#5bc4bf>=</span>utf-8
</span></span><span style=display:flex><span>Content-Length: <span style=color:#f99b15>72</span>
</span></span><span style=display:flex><span>Connection: keep-alive
</span></span><span style=display:flex><span>Node: ipip-myip5
</span></span><span style=display:flex><span>X-Cache: BYPASS
</span></span><span style=display:flex><span>X-Request-Id: e309720b9197e8b94cec18b409c69d1d
</span></span><span style=display:flex><span>Server: WAF
</span></span><span style=display:flex><span>Connection: close
</span></span><span style=display:flex><span>Accept-Ranges: bytes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>当前 IP：101.201.150.47  来自于：中国 北京 北京  阿里云
</span></span></code></pre></div><p>场景二：应用运行前的准备工作</p><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p><p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p><p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p><p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD></code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> alpine:3.4</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span>...<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> addgroup -S redis <span style=color:#5bc4bf>&amp;&amp;</span> adduser -S -G redis redis<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span>...<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>ENTRYPOINT</span> [<span style=color:#48b685>&#34;docker-entrypoint.sh&#34;</span>]<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>EXPOSE</span><span style=color:#48b685> 6379</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>CMD</span> [ <span style=color:#48b685>&#34;redis-server&#34;</span> ]<span style=color:#ef6155>
</span></span></span></code></pre></div><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#776e71>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#776e71></span>...
</span></span><span style=display:flex><span><span style=color:#776e71># allow the container to be started with `--user`</span>
</span></span><span style=display:flex><span><span style=color:#815ba4>if</span> <span style=color:#5bc4bf>[</span> <span style=color:#48b685>&#34;</span><span style=color:#ef6155>$1</span><span style=color:#48b685>&#34;</span> <span style=color:#5bc4bf>=</span> <span style=color:#48b685>&#39;redis-server&#39;</span> -a <span style=color:#48b685>&#34;</span><span style=color:#815ba4>$(</span>id -u<span style=color:#815ba4>)</span><span style=color:#48b685>&#34;</span> <span style=color:#5bc4bf>=</span> <span style=color:#48b685>&#39;0&#39;</span> <span style=color:#5bc4bf>]</span>; <span style=color:#815ba4>then</span>
</span></span><span style=display:flex><span>	find . <span style=color:#f99b15>\!</span> -user redis -exec chown redis <span style=color:#48b685>&#39;{}&#39;</span> +
</span></span><span style=display:flex><span>	exec gosu redis <span style=color:#48b685>&#34;</span><span style=color:#ef6155>$0</span><span style=color:#48b685>&#34;</span> <span style=color:#48b685>&#34;</span><span style=color:#ef6155>$@</span><span style=color:#48b685>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#815ba4>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>exec <span style=color:#48b685>&#34;</span><span style=color:#ef6155>$@</span><span style=color:#48b685>&#34;</span>
</span></span></code></pre></div><p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -it redis id</span>
</span></span><span style=display:flex><span><span style=color:#ef6155>uid</span><span style=color:#5bc4bf>=</span>0<span style=color:#5bc4bf>(</span>root<span style=color:#5bc4bf>)</span> <span style=color:#ef6155>gid</span><span style=color:#5bc4bf>=</span>0<span style=color:#5bc4bf>(</span>root<span style=color:#5bc4bf>)</span> <span style=color:#ef6155>groups</span><span style=color:#5bc4bf>=</span>0<span style=color:#5bc4bf>(</span>root<span style=color:#5bc4bf>)</span>
</span></span></code></pre></div><h2 id=env-设置环境变量>ENV 设置环境变量<a hidden class=anchor aria-hidden=true href=#env-设置环境变量>#</a></h2><p>格式有两种：</p><ul><li><code>ENV &lt;key> &lt;value></code></li><li><code>ENV &lt;key1>=&lt;value1> &lt;key2>=&lt;value2>...</code></li></ul><p><code>ENV</code> 用于设置环境变量，既可以在 Dockerfile 中调用，也可以在构建完的容器运行时中使用。</p><p>支持的指令： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code></p><p>下面这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>ENV</span> <span style=color:#ef6155>VERSION</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>1</span>.0 <span style=color:#ef6155>DEBUG</span><span style=color:#5bc4bf>=</span>on <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#ef6155>NAME</span><span style=color:#5bc4bf>=</span><span style=color:#48b685>&#34;Happy Feet&#34;</span><span style=color:#ef6155>
</span></span></span></code></pre></div><p>示例</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> alpine</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>ENV</span> <span style=color:#ef6155>VERSION</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>1</span>.0 <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#ef6155>DEBUG</span><span style=color:#5bc4bf>=</span>on <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#ef6155>NAME</span><span style=color:#5bc4bf>=</span><span style=color:#48b685>&#34;Happy Feet&#34;</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> echo <span style=color:#48b685>&#34;name: </span><span style=color:#f99b15>${</span><span style=color:#ef6155>NAME</span><span style=color:#f99b15>}</span><span style=color:#48b685>&#34;</span> &gt; /test <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> echo <span style=color:#48b685>&#34;version: </span><span style=color:#f99b15>${</span><span style=color:#ef6155>VERSION</span><span style=color:#f99b15>}</span><span style=color:#48b685>&#34;</span> &gt;&gt; /test<span style=color:#ef6155>
</span></span></span></code></pre></div><p>构建</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker build -t demo-env .</span>
</span></span></code></pre></div><p>构建时调用了环境变量</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -it --rm demo-env cat /test</span>
</span></span><span style=display:flex><span>name: Happy Feet
</span></span><span style=display:flex><span>version: 1.0
</span></span></code></pre></div><p>构建后的容器运行时中调用，这里需要使用 <code>/bin/sh -c</code> 的方式，不然无法读取变量。且对 <code>$</code> 进行转义，不然读取的将会是宿主机的变量</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -it --rm demo-env /bin/sh -c &#34;echo \${DEBUG}&#34;</span>
</span></span><span style=display:flex><span>on
</span></span></code></pre></div><h2 id=arg-构建参数>ARG 构建参数<a hidden class=anchor aria-hidden=true href=#arg-构建参数>#</a></h2><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名>=&lt;值></code> 来覆盖。</p><p>灵活的使用 <code>ARG</code> 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。</p><p>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中，<code>FROM</code> 指令可以是多个</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>ARG</span> <span style=color:#ef6155>DOCKER_USERNAME</span><span style=color:#5bc4bf>=</span>library
</span></span><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> ${DOCKER_USERNAME}/alpine</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> set -x ; echo <span style=color:#f99b15>${</span><span style=color:#ef6155>DOCKER_USERNAME</span><span style=color:#f99b15>}</span><span style=color:#ef6155>
</span></span></span></code></pre></div><p>使用上述 Dockerfile 会发现无法输出 <code>${DOCKER_USERNAME}</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code>，如下示例</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#776e71># 只在 FROM 中生效</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>ARG</span> <span style=color:#ef6155>DOCKER_USERNAME</span><span style=color:#5bc4bf>=</span>library
</span></span><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> ${DOCKER_USERNAME}/alpine</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#776e71># 要想在 FROM 之后使用，必须再次指定</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>ARG</span> <span style=color:#ef6155>DOCKER_USERNAME</span><span style=color:#5bc4bf>=</span>library
</span></span><span style=display:flex><span><span style=color:#815ba4>RUN</span> set -x ; echo <span style=color:#f99b15>${</span><span style=color:#ef6155>DOCKER_USERNAME</span><span style=color:#f99b15>}</span><span style=color:#ef6155>
</span></span></span></code></pre></div><p>如下示例，变量将会在每个 <code>FROM</code> 指令中生效</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#776e71># 这个变量在每个 FROM 中都生效</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>ARG</span> <span style=color:#ef6155>DOCKER_USERNAME</span><span style=color:#5bc4bf>=</span>library
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> ${DOCKER_USERNAME}/alpine</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> set -x ; echo <span style=color:#f99b15>1</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>FROM</span><span style=color:#48b685> ${DOCKER_USERNAME}/alpine</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> set -x ; echo <span style=color:#f99b15>2</span><span style=color:#ef6155>
</span></span></span></code></pre></div><p>如下示例，对于在各个阶段中使用的变量都必须在每个阶段分别指定</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>ARG</span> <span style=color:#ef6155>DOCKER_USERNAME</span><span style=color:#5bc4bf>=</span>library
</span></span><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> ${DOCKER_USERNAME}/alpine</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#776e71># 在FROM 之后使用变量，必须在每个阶段分别指定</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>ARG</span> <span style=color:#ef6155>DOCKER_USERNAME</span><span style=color:#5bc4bf>=</span>library
</span></span><span style=display:flex><span><span style=color:#815ba4>RUN</span> set -x ; echo <span style=color:#f99b15>${</span><span style=color:#ef6155>DOCKER_USERNAME</span><span style=color:#f99b15>}</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>FROM</span><span style=color:#48b685> ${DOCKER_USERNAME}/alpine</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#776e71># 在FROM 之后使用变量，必须在每个阶段分别指定</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>ARG</span> <span style=color:#ef6155>DOCKER_USERNAME</span><span style=color:#5bc4bf>=</span>library
</span></span><span style=display:flex><span><span style=color:#815ba4>RUN</span> set -x ; echo <span style=color:#f99b15>${</span><span style=color:#ef6155>DOCKER_USERNAME</span><span style=color:#f99b15>}</span><span style=color:#ef6155>
</span></span></span></code></pre></div><h2 id=volume-定义匿名卷>VOLUME 定义匿名卷<a hidden class=anchor aria-hidden=true href=#volume-定义匿名卷>#</a></h2><p>格式为：</p><ul><li><code>VOLUME ["&lt;路径1>", "&lt;路径2>"...]</code></li><li><code>VOLUME &lt;路径></code></li></ul><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。</p><p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据，从而保证了容器存储层的无状态化。</p><p><code>VOLUME</code> 创建的匿名卷会挂载到系统 <code>/var/lib/docker/volumes/&lt;CONTAINER-ID>/&lt;_VOLUME></code> 目录下，且不会随着容器删除而删除，需要手动删除</p><p>如下示例</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> alpine</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>VOLUME</span><span style=color:#48b685> /data</span><span style=color:#ef6155>
</span></span></span></code></pre></div><p>构建运行</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker build -t demo-volume .</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -itd --name=demo-volume demo-volume </span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec -it demo-volume ls -ld /data</span>
</span></span><span style=display:flex><span>drwxr-xr-x    <span style=color:#f99b15>2</span> root     root          <span style=color:#f99b15>4096</span> Apr <span style=color:#f99b15>10</span> 05:24 /data
</span></span></code></pre></div><p>查看挂载目录</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker inspect --format=&#39;{{json .Mounts}}&#39; demo-volume | python -m json.tool</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>
</span></span><span style=display:flex><span>    <span style=color:#5bc4bf>{</span>
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;Destination&#34;</span>: <span style=color:#48b685>&#34;/data&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;Driver&#34;</span>: <span style=color:#48b685>&#34;local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;Mode&#34;</span>: <span style=color:#48b685>&#34;&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;Name&#34;</span>: <span style=color:#48b685>&#34;49cf915dd297292e3d0e4b2c7a66ead6875cfb0dbd010de15189040ab1158b3b&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;Propagation&#34;</span>: <span style=color:#48b685>&#34;&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;RW&#34;</span>: true,
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;Source&#34;</span>: <span style=color:#48b685>&#34;/var/lib/docker/volumes/49cf915dd297292e3d0e4b2c7a66ead6875cfb0dbd010de15189040ab1158b3b/_data&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;Type&#34;</span>: <span style=color:#48b685>&#34;volume&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#5bc4bf>}</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>]</span>
</span></span></code></pre></div><p>如下示例，运行容器时，可以指定 <code>-v</code> 参数将目录挂载到指定位置</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -itd -v /mydata:/data --name demo-volume-2 demo-volume</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker inspect --format=&#39;{{json .Mounts}}&#39; demo-volume-2 | python -m json.tool</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>
</span></span><span style=display:flex><span>    <span style=color:#5bc4bf>{</span>
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;Destination&#34;</span>: <span style=color:#48b685>&#34;/data&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;Mode&#34;</span>: <span style=color:#48b685>&#34;&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;Propagation&#34;</span>: <span style=color:#48b685>&#34;rprivate&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;RW&#34;</span>: true,
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;Source&#34;</span>: <span style=color:#48b685>&#34;/mydata&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#48b685>&#34;Type&#34;</span>: <span style=color:#48b685>&#34;bind&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#5bc4bf>}</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>]</span>
</span></span></code></pre></div><h2 id=expose-暴露端口>EXPOSE 暴露端口<a hidden class=anchor aria-hidden=true href=#expose-暴露端口>#</a></h2><p>格式为 <code>EXPOSE &lt;端口1> [端口2] ...</code></p><p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务</p><p>在 Dockerfile 中写入这样的声明有两个好处：</p><ul><li>一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；</li><li>另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</li></ul><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口>:&lt;容器端口></code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h2 id=workdir-指定工作目录>WORKDIR 指定工作目录<a hidden class=anchor aria-hidden=true href=#workdir-指定工作目录>#</a></h2><p>格式为 <code>WORKDIR &lt;路径></code></p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录</p><p>如下示例，是一个常见的错误，<code>world.txt</code> 最终会在 <code>/app</code> 目录下，而不是期望的 <code>/app/demo</code> 目录</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>WORKDIR</span><span style=color:#48b685> /app</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> mkdir demo <span style=color:#5bc4bf>&amp;&amp;</span> cd demo<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> echo <span style=color:#48b685>&#34;hello&#34;</span> &gt; world.txt<span style=color:#ef6155>
</span></span></span></code></pre></div><p>上述需求可以进行如下优化，推荐使用第二种写法</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>WORKDIR</span><span style=color:#48b685> /app/demo</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> echo <span style=color:#48b685>&#34;hello&#34;</span> &gt; world.txt<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#776e71># 或者</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>WORKDIR</span><span style=color:#48b685> /app</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> mkdir demo <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> echo <span style=color:#48b685>&#34;hello&#34;</span> &gt; demo/world.txt<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#776e71># 或者</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>WORKDIR</span><span style=color:#48b685> /app</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> mkdir demo <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> cd demo <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> echo <span style=color:#48b685>&#34;hello&#34;</span> &gt; demo/world.txt<span style=color:#ef6155>
</span></span></span></code></pre></div><p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关</p><p>如下示例，<code>pwd</code> 的输出将会是 <code>/a/b/c</code></p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>WORKDIR</span><span style=color:#48b685> /a</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>WORKDIR</span><span style=color:#48b685> b</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>WORKDIR</span><span style=color:#48b685> c</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> pwd<span style=color:#ef6155>
</span></span></span></code></pre></div><h2 id=user-指定当前用户>USER 指定当前用户<a hidden class=anchor aria-hidden=true href=#user-指定当前用户>#</a></h2><p>格式：<code>USER &lt;用户名>[:&lt;用户组>]</code></p><p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p><p>注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>RUN</span> groupadd -r redis <span style=color:#5bc4bf>&amp;&amp;</span> useradd -r -g redis redis<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>USER</span><span style=color:#48b685> redis</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> <span style=color:#5bc4bf>[</span> <span style=color:#48b685>&#34;redis-server&#34;</span> <span style=color:#5bc4bf>]</span><span style=color:#ef6155>
</span></span></span></code></pre></div><p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a href=https://github.com/tianon/gosu target=_blank rel=noopener style=color:#42b983 ;>gosu</a></p><p>不过更推荐的还是 <a href=#entrypoint-%e5%85%a5%e5%8f%a3%e7%82%b9>上文</a> 中提到过的通过 <code>ENTRYPOINT</code> 脚本的方式</p><p>使用 <code>gosu</code> 示例</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#776e71># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> groupadd -r redis <span style=color:#5bc4bf>&amp;&amp;</span> useradd -r -g redis redis<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#776e71># 下载 gosu</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> wget -O /usr/local/bin/gosu <span style=color:#48b685>&#34;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&#34;</span> <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> chmod +x /usr/local/bin/gosu <span style=color:#f99b15>\
</span></span></span><span style=display:flex><span><span style=color:#f99b15></span>    <span style=color:#5bc4bf>&amp;&amp;</span> gosu nobody true<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#776e71># 设置 CMD，并以另外的用户执行</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>CMD</span> [ <span style=color:#48b685>&#34;exec&#34;</span>, <span style=color:#48b685>&#34;gosu&#34;</span>, <span style=color:#48b685>&#34;redis&#34;</span>, <span style=color:#48b685>&#34;redis-server&#34;</span> ]<span style=color:#ef6155>
</span></span></span></code></pre></div><h2 id=healthcheck-健康检查>HEALTHCHECK 健康检查<a hidden class=anchor aria-hidden=true href=#healthcheck-健康检查>#</a></h2><p>格式：</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令></code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li></ul><p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p><p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p><p><code>HEALTHCHECK</code> 支持下列选项：</p><ul><li><code>--interval=&lt;间隔></code>：两次健康检查的间隔，默认为 30 秒；</li><li><code>--timeout=&lt;时长></code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li><li><code>--retries=&lt;次数></code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li></ul><p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p><p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：</p><ul><li><code>0</code>：成功；</li><li><code>1</code>：失败；</li><li><code>2</code>：保留，不要使用这个值。</li></ul><p>如下示例，假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> nginx</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>HEALTHCHECK --interval=5s --timeout=3s --retries=3\
</span></span></span><span style=display:flex><span><span style=color:#ef6155>  </span><span style=color:#815ba4>CMD</span> curl -fs http://localhost/ <span style=color:#5bc4bf>||</span> exit <span style=color:#f99b15>1</span><span style=color:#ef6155>
</span></span></span></code></pre></div><p>构建运行</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker build -t myweb .</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -d --name demo-myweb -p 800:80 myweb</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#776e71># 此时是 starting 状态</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker ps | grep myweb</span>
</span></span><span style=display:flex><span>e6f585df60a6   myweb  <span style=color:#48b685>&#34;/docker-entrypoint.…&#34;</span>   About a minute ago   Up <span style=color:#f99b15>2</span> seconds <span style=color:#5bc4bf>(</span>health: starting<span style=color:#5bc4bf>)</span>   0.0.0.0:800-&gt;80/tcp  demo-myweb
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#776e71># 等待几秒变为 healthy 状态</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker ps | grep myweb</span>
</span></span><span style=display:flex><span>e6f585df60a6 myweb <span style=color:#48b685>&#34;/docker-entrypoint.…&#34;</span>   <span style=color:#f99b15>2</span> minutes ago Up About a minute <span style=color:#5bc4bf>(</span>healthy<span style=color:#5bc4bf>)</span>  0.0.0.0:800-&gt;80/tcp  demo-myweb
</span></span></code></pre></div><p>删除 <code>index.html</code> 文件模拟故障</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec -it demo-myweb rm -f /usr/share/nginx/html/index.html</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#776e71># 状态变为unhealthy</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker ps | grep myweb</span>
</span></span><span style=display:flex><span>e6f585df60a6  myweb  <span style=color:#48b685>&#34;/docker-entrypoint.…&#34;</span>   <span style=color:#f99b15>6</span> minutes ago   Up <span style=color:#f99b15>5</span> minutes <span style=color:#5bc4bf>(</span>unhealthy<span style=color:#5bc4bf>)</span>  0.0.0.0:800-&gt;80/tcp   demo-myweb
</span></span></code></pre></div><p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker inspect --format &#39;{{json .State.Health}}&#39; demo-myweb | python -m json.tool</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>{</span>
</span></span><span style=display:flex><span>    <span style=color:#48b685>&#34;FailingStreak&#34;</span>: 25,
</span></span><span style=display:flex><span>    <span style=color:#48b685>&#34;Log&#34;</span>: <span style=color:#5bc4bf>[</span>
</span></span><span style=display:flex><span>        <span style=color:#5bc4bf>{</span>
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;End&#34;</span>: <span style=color:#48b685>&#34;2023-04-10T14:41:51.393698555+08:00&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;ExitCode&#34;</span>: 1,
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;Output&#34;</span>: <span style=color:#48b685>&#34;&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;Start&#34;</span>: <span style=color:#48b685>&#34;2023-04-10T14:41:51.285647058+08:00&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#5bc4bf>}</span>,
</span></span><span style=display:flex><span>        <span style=color:#5bc4bf>{</span>
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;End&#34;</span>: <span style=color:#48b685>&#34;2023-04-10T14:41:56.504282619+08:00&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;ExitCode&#34;</span>: 1,
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;Output&#34;</span>: <span style=color:#48b685>&#34;&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;Start&#34;</span>: <span style=color:#48b685>&#34;2023-04-10T14:41:56.401745529+08:00&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#5bc4bf>}</span>,
</span></span><span style=display:flex><span>...........
</span></span><span style=display:flex><span>    <span style=color:#5bc4bf>]</span>,
</span></span><span style=display:flex><span>    <span style=color:#48b685>&#34;Status&#34;</span>: <span style=color:#48b685>&#34;unhealthy&#34;</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>}</span>
</span></span></code></pre></div><p>恢复文件</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec -it demo-myweb /bin/bash</span>
</span></span><span style=display:flex><span>root@e6f585df60a6:/# echo test &gt; /usr/share/nginx/html/index.html
</span></span><span style=display:flex><span>root@e6f585df60a6:/#
</span></span><span style=display:flex><span>exit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@lvbibir learn<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker inspect --format &#39;{{json .State.Health}}&#39; demo-myweb | python -m json.tool</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>{</span>
</span></span><span style=display:flex><span>    <span style=color:#48b685>&#34;FailingStreak&#34;</span>: 0,
</span></span><span style=display:flex><span>    <span style=color:#48b685>&#34;Log&#34;</span>: <span style=color:#5bc4bf>[</span>
</span></span><span style=display:flex><span>        <span style=color:#5bc4bf>{</span>
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;End&#34;</span>: <span style=color:#48b685>&#34;2023-04-10T14:48:30.482498808+08:00&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;ExitCode&#34;</span>: 0,
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;Output&#34;</span>: <span style=color:#48b685>&#34;test\n&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;Start&#34;</span>: <span style=color:#48b685>&#34;2023-04-10T14:48:30.378197999+08:00&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#5bc4bf>}</span>,
</span></span><span style=display:flex><span>        <span style=color:#5bc4bf>{</span>
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;End&#34;</span>: <span style=color:#48b685>&#34;2023-04-10T14:48:35.599150547+08:00&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;ExitCode&#34;</span>: 0,
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;Output&#34;</span>: <span style=color:#48b685>&#34;test\n&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#48b685>&#34;Start&#34;</span>: <span style=color:#48b685>&#34;2023-04-10T14:48:35.490433323+08:00&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#5bc4bf>}</span>,
</span></span><span style=display:flex><span>.......
</span></span><span style=display:flex><span>    <span style=color:#5bc4bf>]</span>,
</span></span><span style=display:flex><span>    <span style=color:#48b685>&#34;Status&#34;</span>: <span style=color:#48b685>&#34;healthy&#34;</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>}</span>
</span></span></code></pre></div><h2 id=onbuild-为他人作嫁衣裳>ONBUILD 为他人作嫁衣裳<a hidden class=anchor aria-hidden=true href=#onbuild-为他人作嫁衣裳>#</a></h2><p>格式：<code>ONBUILD &lt;其它指令></code>。</p><p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p><p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> node:slim</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>WORKDIR</span><span style=color:#48b685> /app</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>COPY</span> ./package.json /app<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> <span style=color:#5bc4bf>[</span> <span style=color:#48b685>&#34;npm&#34;</span>, <span style=color:#48b685>&#34;install&#34;</span> <span style=color:#5bc4bf>]</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>COPY</span> . /app/<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>CMD</span> [ <span style=color:#48b685>&#34;npm&#34;</span>, <span style=color:#48b685>&#34;start&#34;</span> ]<span style=color:#ef6155>
</span></span></span></code></pre></div><p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p><p>如果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p><p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。</p><p>基础镜像(my-node) <code>Dockerfile</code></p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> node:slim</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>WORKDIR</span><span style=color:#48b685> /app</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>CMD</span> [ <span style=color:#48b685>&#34;npm&#34;</span>, <span style=color:#48b685>&#34;start&#34;</span> ]<span style=color:#ef6155>
</span></span></span></code></pre></div><p>应用镜像(my-app1) <code>Dockerfile</code></p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> my-node</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>COPY</span> ./package.json /app<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> <span style=color:#5bc4bf>[</span> <span style=color:#48b685>&#34;npm&#34;</span>, <span style=color:#48b685>&#34;install&#34;</span> <span style=color:#5bc4bf>]</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>COPY</span> . /app/<span style=color:#ef6155>
</span></span></span></code></pre></div><p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新。</p><p>那么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p><p><code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> node:slim</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>WORKDIR</span><span style=color:#48b685> /app</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>ONBUILD</span> <span style=color:#815ba4>COPY</span> ./package.json /app<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>ONBUILD</span> <span style=color:#815ba4>RUN</span> <span style=color:#5bc4bf>[</span> <span style=color:#48b685>&#34;npm&#34;</span>, <span style=color:#48b685>&#34;install&#34;</span> <span style=color:#5bc4bf>]</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>ONBUILD</span> <span style=color:#815ba4>COPY</span> . /app/<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>CMD</span> [ <span style=color:#48b685>&#34;npm&#34;</span>, <span style=color:#48b685>&#34;start&#34;</span> ]<span style=color:#ef6155>
</span></span></span></code></pre></div><p>应用镜像 <code>Dcokerfile</code></p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>FROM</span><span style=color:#48b685> my-node</span><span style=color:#ef6155>
</span></span></span></code></pre></div><p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p><h2 id=label-为镜像添加元数据>LABEL 为镜像添加元数据<a hidden class=anchor aria-hidden=true href=#label-为镜像添加元数据>#</a></h2><p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据（metadata）。</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>LABEL</span> &lt;key&gt;<span style=color:#5bc4bf>=</span>&lt;value&gt; &lt;key&gt;<span style=color:#5bc4bf>=</span>&lt;value&gt; &lt;key&gt;<span style=color:#5bc4bf>=</span>&lt;value&gt; ...<span style=color:#ef6155>
</span></span></span></code></pre></div><p>我们还可以用一些标签来申明镜像的作者、文档地址等：</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>LABEL</span> org.opencontainers.image.authors<span style=color:#5bc4bf>=</span><span style=color:#48b685>&#34;yeasy&#34;</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>LABEL</span> org.opencontainers.image.documentation<span style=color:#5bc4bf>=</span><span style=color:#48b685>&#34;https://yeasy.gitbooks.io&#34;</span><span style=color:#ef6155>
</span></span></span></code></pre></div><p>具体可以参考 <a href=https://github.com/opencontainers/image-spec/blob/master/annotations.md target=_blank rel=noopener style=color:#42b983 ;>https://github.com/opencontainers/image-spec/blob/master/annotations.md</a></p><h2 id=shell-指定shell>SHELL 指定shell<a hidden class=anchor aria-hidden=true href=#shell-指定shell>#</a></h2><p>格式：<code>SHELL ["executable", "parameters"]</code></p><p><code>SHELL</code> 指令可以指定 <code>RUN</code> <code>ENTRYPOINT</code> <code>CMD</code> 指令的 shell，Linux 中默认为 `["/bin/sh", &ldquo;-c&rdquo;]</p><p>如下示例，两个 <code>RUN</code> 运行同一命令，第二个 <code>RUN</code> 运行的命令会打印出每条命令并当遇到错误时退出。</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>SHELL</span> [<span style=color:#48b685>&#34;/bin/sh&#34;</span>, <span style=color:#48b685>&#34;-c&#34;</span>]<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> lll ; ls<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>SHELL</span> [<span style=color:#48b685>&#34;/bin/sh&#34;</span>, <span style=color:#48b685>&#34;-cex&#34;</span>]<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>RUN</span> lll ; ls<span style=color:#ef6155>
</span></span></span></code></pre></div><p>如下示例，当 <code>ENTRYPOINT</code> <code>CMD</code> 以 shell 格式指定时，<code>SHELL</code> 指令所指定的 shell 也会成为这两个指令的 shell</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#815ba4>SHELL</span> [<span style=color:#48b685>&#34;/bin/sh&#34;</span>, <span style=color:#48b685>&#34;-cex&#34;</span>]<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#776e71># /bin/sh -cex &#34;nginx&#34;</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>ENTRYPOINT</span> nginx<span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#776e71># /bin/sh -cex &#34;nginx&#34;</span><span style=color:#ef6155>
</span></span></span><span style=display:flex><span><span style=color:#ef6155></span><span style=color:#815ba4>CMD</span> nginx<span style=color:#ef6155>
</span></span></span></code></pre></div></div><div class=post-reward><div style=padding:0;margin:0;width:100%;font-size:16px;text-align:center><div id=QR style=opacity:0><div id=wechat style=display:inline-block><a class=fancybox rel=group><img id=wechat_qr src=https://www.lvbibir.cn/img/wechat_pay.png alt=wechat_pay></a><p>微信</p></div><div id=alipay style=display:inline-block><a class=fancybox rel=group><img id=alipay_qr src=https://www.lvbibir.cn/img/alipay.png alt=alipay></a><p>支付宝</p></div></div><button id=rewardButton onclick='var qr=document.getElementById("QR");qr.style.opacity==="0"?qr.style.opacity="1":qr.style.opacity="0"'>
<span>🧧 鼓励</span></button></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://www.lvbibir.cn/en/posts/tech/docker-dockerfile-optimization/><span class=title>« 上一页</span><br><span>docker | dockerfile最佳实践</span></a>
<a class=next href=https://www.lvbibir.cn/en/posts/tech/linux-command-kill/><span class=title>下一页 »</span><br><span>linux | kill命令详解以及linux中的信号</span></a></nav></footer></div><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://cdn.staticfile.org/twikoo/1.6.15/twikoo.all.min.js></script><script>twikoo.init({envId:"https://twikoo.lvbibir.cn/",el:"#tcomment",lang:"zh-CN",path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><a href=https://gohugo.io/ target=_blank><img style=display:unset src=https://image.lvbibir.cn/blog/frame-hugo-blue.svg></a>
<a href=https://github.com/adityatelange/hugo-PaperMod target=_blank><img style=display:unset src=https://image.lvbibir.cn/blog/theme-papermod-lightgrey.svg></a>
<a href=https://cn.aliyun.com/ target=_blank><img style=display:unset src=https://image.lvbibir.cn/blog/图床-阿里云-orange.svg></a><br><span id=runtime_span></span>
<script type=text/javascript>function show_runtime(){window.setTimeout("show_runtime()",1e3),X=new Date("7/13/2021 1:00:00"),Y=new Date,T=Y.getTime()-X.getTime(),M=24*60*60*1e3,a=T/M,A=Math.floor(a),b=(a-A)*24,B=Math.floor(b),c=(b-B)*60,C=Math.floor((b-B)*60),D=Math.floor((c-C)*60),runtime_span.innerHTML="网站已运行"+A+"天"+B+"小时"+C+"分"+D+"秒"}show_runtime()</script>|
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span id=busuanzi_container>总访客数: <span id=busuanzi_value_site_uv></span>
|
总访问量: <span id=busuanzi_value_site_pv></span></span><br><a href=https://beian.miit.gov.cn/ target=_blank style="border-bottom:1px solid">京ICP备2021023168号-1</a>&nbsp;
|
<span>Copyright
&copy;
2020-2023
<a href=https://www.lvbibir.cn/en/ style="border-bottom:1px solid">lvbibir's Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg><span id=read_progress></span></span></a>
<script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>400||document.documentElement.scrollTop>400?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="📄复制";function c(){t.innerText="👌🏻已复制!",setTimeout(()=>{t.innerText="📄复制"},2e3)}t.addEventListener("click",t=>{const n=document.createRange();n.selectNodeContents(e);const s=window.getSelection();s.removeAllRanges(),s.addRange(n);try{document.execCommand("copy"),c()}catch{}s.removeRange(n)});let l=e.className.replaceAll("language-",""),n=document.createElement("div"),i=document.createElement("div"),a=document.createElement("div"),r=document.createElement("div"),o=document.createElement("div");o.innerText=l,n.setAttribute("class","mac-tool"),i.setAttribute("class","mac bb1"),a.setAttribute("class","mac bb2"),r.setAttribute("class","mac bb3"),o.setAttribute("class","language-type"),n.appendChild(i),n.appendChild(a),n.appendChild(r),n.appendChild(o),s.classList.contains("highlight")?(s.appendChild(t),s.appendChild(n)):s.parentNode.firstChild===s||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName==="TABLE"?(e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t),s.appendChild(n)):(e.parentNode.appendChild(t),s.appendChild(n)))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script>
<script>$("code[class^=language] ").on("mouseover",function(){$(window).width()>768&&this.clientWidth<this.scrollWidth&&($(this).css("width","135%"),$(this).css("border-top-right-radius","var(--radius)"))}).on("mouseout",function(){$(this).css("width","100%"),$(this).css("border-top-right-radius","unset")})</script></body></html>