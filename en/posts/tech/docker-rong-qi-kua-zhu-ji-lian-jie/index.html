<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>docker | 容器的跨主机连接 | lvbibir's Blog</title>
<meta name=keywords content="linux,docker,network"><meta name=description content="介绍 docker 容器在不同宿主机下实现通信的几种方案"><meta name=author content="作者:&nbsp;lvbibir"><link rel=canonical href=https://www.lvbibir.cn/en/posts/tech/docker-rong-qi-kua-zhu-ji-lian-jie/><link crossorigin=anonymous href=/assets/css/stylesheet.ea2d3aa74caabd1c227305342e99c488a04870896b2f729dec906b90f7870787.css integrity="sha256-6i06p0yqvRwicwU0LpnEiKBIcIlrL3Kd7JBrkPeHB4c=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.lvbibir.cn/img/avatar.gif><link rel=icon type=image/png sizes=16x16 href=https://www.lvbibir.cn/img/avatar.gif><link rel=icon type=image/png sizes=32x32 href=https://www.lvbibir.cn/img/avatar.gif><link rel=apple-touch-icon href=https://www.lvbibir.cn/img/avatar.gif><link rel=mask-icon href=https://www.lvbibir.cn/img/avatar.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="docker | 容器的跨主机连接"><meta property="og:description" content="介绍 docker 容器在不同宿主机下实现通信的几种方案"><meta property="og:type" content="article"><meta property="og:url" content="https://www.lvbibir.cn/en/posts/tech/docker-rong-qi-kua-zhu-ji-lian-jie/"><meta property="og:image" content="https://image.lvbibir.cn/blog/docker.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-28T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://image.lvbibir.cn/blog/docker.png"><meta name=twitter:title content="docker | 容器的跨主机连接"><meta name=twitter:description content="介绍 docker 容器在不同宿主机下实现通信的几种方案"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"docker | 容器的跨主机连接","item":"https://www.lvbibir.cn/en/posts/tech/docker-rong-qi-kua-zhu-ji-lian-jie/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"docker | 容器的跨主机连接","name":"docker | 容器的跨主机连接","description":"介绍 docker 容器在不同宿主机下实现通信的几种方案","keywords":["linux","docker","network"],"articleBody":"0 前言 实现跨主机的 docker 容器之间的通讯：\n使用网桥实现跨主机的连接 docker 原生的网络：overlay、macvlan 第三方网络：flaanel、weave、calic 1 网桥 2 open vswitch 3 weave 4 macvlan 4.1 简介 macvlan 是 Linux 操作系统内核提供的网络虚拟化方案之一，更准确的说法是网卡虚拟化方案。它可以为一张物理网卡设置多个 mac 地址，相当于物理网卡施展了影分身之术，由一个变多个，同时要求物理网卡打开混杂模式。针对每个 mac 地址，都可以设置 IP 地址，本来是一块物理网卡连接到交换机，现在是多块虚拟网卡连接到交换机。\n当容器需要直连入物理网络时，可以使用 Macvlan。Macvlan 本身不创建网络，本质上首先使宿主机物理网卡工作在‘混杂模式’，这样物理网卡的 MAC 地址将会失效，所有二层网络中的流量物理网卡都能收到。接下来就是在这张物理网卡上创建虚拟网卡，并为虚拟网卡指定 MAC 地址，实现一卡多用，在物理网络看来，每张虚拟网卡都是一个单独的接口。使用 Macvlan 有几点需要注意：\n容器直接连接物理网络，由物理网络负责分配 IP 地址，可能的结果是物理网络 IP 地址被耗尽，另一个后果是网络性能问题，物理网络中接入的主机变多，广播包占比快速升高而引起的网络性能下降问题。 前边说过了，宿主机上的某张网上需要工作在‘混乱模式’下。 从长远来看 bridge 网络与 overlay 网络是更好的选择，原因就是虚拟网络应该与物理网络隔离而不是共享。 优缺点：\n优点是性能非常好 缺点是地址需要手动分配 Macvlan 网络有两种模式：bridge 模式与 802.1q trunk bridge 模式。\nbridge 模式，Macvlan 网络流量直接使用宿主机物理网卡。 802.1q trunk bridge 模式，Macvlan 网络流量使用 Docker 动态创建的 802.1q 子接口，对于路由与过虑，这种模式能够提供更细粒度的控制 4.2 部署 环境准备：\n两台 centos7 docker 版本：18.03 ip：192.168.0.53（node-1） 192.168.0.54（node-2） [root@node-1 ~]# ip link show ens33 [root@node-1 ~]# ip link set ens32 promisc on #开启混杂模式，保证多个ip可以通过 [root@node-1 ~]# docker network create -d macvlan --subnet 10.0.0.0/24 --gateway=10.0.0.1 -o parent=ens33 mac_net1 [root@node-1 ~]# docker network ls node-1 docker run -itd --name bbox-1 --ip 10.0.0.11 --network mac_net1 busybox node-2 docker run -itd --name bbox-2 --ip 10.0.0.12 --network mac_net1 busybox node-1 [root@node-1 ~]# docker exec bbox-1 ping 10.0.0.12 [root@node-1 ~]# docker exec bbox-1 ping bbox-2 可以 ping 通 ip，但是无法 ping 通主机名，因为它没有 dns 解析\n[root@node-1 ~]# brctl show 因为 macvlan 不依赖于 bridge 网络，所以查看不到新的桥接网络\n[root@node-1 ~]# docker exec bbox-1 ip link 查看到 eth0 连接到了 if2\n[root@node-1 ~]# ip link show ens33 可以查看到 ens33 的编号是 2，即 bbox-1 容器的 eth0 网卡连接到了 ens33 物理网卡\n[root@node-1 ~]# docker network create -d macvlan -o parent=ens33 mac_net2 Error response from daemon: network dm-b34ee1020a96 is already using parent interface ens33 再创建 macvlan 网络时发现已经无法再创建，即一块网卡只能添加一个 macvlan 的地址\n4.3 一块网卡绑定多个 macvlan 地址 [root@node-1 ~]# modinfo 8021q # 查看内核是否支持802.1q封装 [root@node-1 ~]# modprobe 8021q # 如果上条命令执行后没有结果，使用该命令加载该模块 node-1 [root@node-1 ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33 BOOTPROTO=manual 修改为不需要 ip 的 manual 模式\nnode-2 [root@node-2 ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens32 BOOTPROTO=manual node-1 添加两块虚拟网卡，注意与实际的 ens32 网卡的网段区分开\nens32 使用的是 192.168.0.0/24 网段，虚拟网卡使用的是 192.168.1.0/24 和 192.168.2.0/24\n[root@node-1 ~]# cp -p /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-ens33.10 [root@node-1 ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33.10 BOOTPROTO=none NAME=ens33.10 DEVICE=ens33.10 ONBOOT=yes IPADDR=192.168.1.10 PREFIX=24 NETWORK=192.168.1.0 VLAN=yes [root@node-1 ~]# cp -p /etc/sysconfig/network-scripts/ifcfg-ens33.10 /etc/sysconfig/network-scripts/ifcfg-ens33.20 [root@node-1 ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33.20 BOOTPROTO=none NAME=ens33.20 DEVICE=ens33.20 ONBOOT=yes IPADDR=192.168.2.10 PREFIX=24 NETWORK=192.168.2.0 VLAN=yes [root@node-1 ~]# ifup ens33.10 [root@node-1 ~]# ifup ens33.20 [root@node-1 ~]# scp /etc/sysconfig/network-scripts/ifcfg-ens33.10 192.168.0.54:/etc/sysconfig/network-scripts/ifcfg-ens32.10 [root@node-1 ~]# scp /etc/sysconfig/network-scripts/ifcfg-ens33.20 192.168.0.54:/etc/sysconfig/network-scripts/ifcfg-ens32.20 node-2 [root@node-2 ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens32.10 BOOTPROTO=none NAME=ens32.10 DEVICE=ens32.10 ONBOOT=yes IPADDR=192.168.1.20 PREFIX=24 NETWORK=192.168.1.0 VLAN=yes [root@node-2 ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens32.20 BOOTPROTO=none NAME=ens32.20 DEVICE=ens32.20 ONBOOT=yes IPADDR=192.168.2.20 PREFIX=24 NETWORK=192.168.2.0 VLAN=yes [root@node-2 ~]# ifup ens32.10 [root@node-2 ~]# ifup ens32.20 node-1 [root@node-1 ~]# docker network create -d macvlan --subnet 172.16.11.0/24 --gateway 172.16.11.1 -o parent=ens33.10 mac_net11 [root@node-1 ~]# docker network create -d macvlan --subnet 172.16.12.0/24 --gateway 172.16.12.1 -o parent=ens33.20 mac_net12 node-2 [root@node-2 ~]# docker network create -d macvlan --subnet 172.16.11.0/24 --gateway 172.16.11.1 -o parent=ens32.10 mac_net11 [root@node-2 ~]# docker network create -d macvlan --subnet 172.16.12.0/24 --gateway 172.16.12.1 -o parent=ens32.20 mac_net12 node-1 [root@node-2 ~]# docker run -itd --name bbox-11 --ip=172.16.11.11 --network mac_net11 busybox [root@node-2 ~]# docker run -itd --name bbox-12 --ip=172.16.12.11 --network mac_net12 busybox node-2 [root@node-2 ~]# docker run -itd --name bbox-21 --ip=172.16.11.12 --network mac_net11 busybox [root@node-2 ~]# docker run -itd --name bbox-22 --ip=172.16.12.12 --network mac_net12 busybox node-1 [root@node-1 ~]# docker exec bbox-11 ping 172.16.11.12 PING 172.16.11.12 (172.16.11.12): 56 data bytes 64 bytes from 172.16.11.12: seq=0 ttl=64 time=0.867 ms 64 bytes from 172.16.11.12: seq=1 ttl=64 time=1.074 ms 64 bytes from 172.16.11.12: seq=2 ttl=64 time=1.145 ms 64 bytes from 172.16.11.12: seq=3 ttl=64 time=0.938 ms ^C [root@node-1 ~]# docker exec bbox-12 ping 172.16.12.12 PING 172.16.12.12 (172.16.12.12): 56 data bytes 64 bytes from 172.16.12.12: seq=0 ttl=64 time=0.858 ms 64 bytes from 172.16.12.12: seq=1 ttl=64 time=1.140 ms 64 bytes from 172.16.12.12: seq=2 ttl=64 time=0.818 ms 64 bytes from 172.16.12.12: seq=3 ttl=64 time=1.056 ms ^C 在两台系统进行修改，添加网关，修改防火墙策略 node-1 中记得将 ens32 更换为 ens33 ifconfig ens32.10 172.16.10.1 netmask 255.255.255.0 ifconfig ens32.20 172.16.20.1 netmask 255.255.255.0 iptables -t nat -A POSTROUTING -o ens32.10 -j MASQUERADE iptables -t nat -A POSTROUTING -o ens32 -j MASQUERADE iptables -A FORWARD -i ens32.10 -o ens32 -m state --state RELATE,ESTABLISHED -j ACCEPT iptables -A FORWARD -i ens32 -o ens32.10 -m state --state RELATE,ESTABLISHED -j ACCEPT iptables -A FORWARD -i ens32.10 -o ens32 -j ACCEPT iptables -A FORWARD -i ens32 -o ens32.10 -j ACCEPT 5 overlay 5.1 简介 5.2 准备 overlay 环境 为支持容器的跨主机通信，Docker 提供了 overlay driver。Docker overlay 网络需要一个 key-value 数据库用于保存网络状态信息，包括 Network、Endpoint、IP 等。Consul、Etcd 和 ZooKeeper 都是 Docker 支持的 key-value 软件，这里我们使用 Consul\n环境描述 节点 系统版本 docker 版本 角色 IP 地址 node-1 centos7.4 docker-18.03.0 consul 192.168.0.101 node-2 centos7.4 docker-18.03.0 host 192.168.0.102 node-3 centos7.4 docker-18.03.0 host 192.168.0.103 创建 consul node-1; [root@node-1 ~]# docker run -d -p 8500:8500 -h consul --name consul progrium/consul -server -bootstrap 容器启动后可以通过 192.168.0.101:8500 访问到 consul\n修改 docker 配置文件 修改 node-2 和 node-3 的 docker daemon 的配置文件/etc/systemd/system/docker.service\n[root@node-2 ~]# vim /etc/systemd/system/docker.service ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2376 -H unix:///var/run/docker.sock --cluster-store=consul://192.168.0.101:8500 --cluster-advertise=ens32:2376 [root@node-2 ~]# systemctl daemon-reload [root@node-2 ~]# systemctl restart docker -H ：tcp：允许 tcp 连接 daemon -H：unix：默认的 socket 连接方式，支持远程的同时，本地也可以连接 –cluster-store 指定 consul 的地址 –cluster-advertise 告知 consul 自己的连接地址 node-2 和 node-3 会自动注册到 consul 数据库中。\n5.3 创建 overlay 网络 在 node-2 中创建网络 在 node-2 中创建 overlay 网络 ov_net1\n[root@node-2 ~]# docker network create -d overlay ov_net1 -d overlay：指定 driver 为 overlay [root@node-2 ~]# docker network ls node-3 查看创建的网络 注意到 ov_net1 的 SCOPE 为 global，而其他网络为 local 。在 node-3 上查看存在的网络:\n[root@node-3 ~]# docker network ls node-3 上也能看到 ov_net1，只是因为创建 ov_net1 时将 overlay 网络信息存入了 consul，node-3 从 consul 读取到了新网络数据。之后 ov_net1 的任何变化都会同步到 node-2 和 node-3\n查看 ov_net1 详细信息 [root@node-2 ~]# docker network inspect ov_net1 IPAM 是指 IP Address Management，docker 自动为 ov_net1 分配的 IP 空间为 10.0.0.0/24\n5.4 在 overlay 中运行容器 创建容器 bbox-1 在 node-2 上运行一个 busybox 容器并连接到 ov_net1.\n[root@node-2 ~]# docker run -itd --name bbox-1 --network ov_net1 busybox 查看 bbox-1 网络配置 [root@node-2 ~]# docker exec bbox-1 ip r default via 172.18.0.1 dev eth1 10.0.0.0/24 dev eth0 scope link src 10.0.0.2 172.18.0.0/16 dev eth1 scope link src 172.18.0.2 bbox-1 有两个网络接口，eth0 和 eth1 eth0 IP 为 10.0.0.2，连接的是 overlay 网络 ov_net1 eth1 IP 为 172.18.0.2 容器的默认路由是走 eth1，其实，docker 会创建一个 bridge 网络 “docker_gwbridge”，为所有连接到 overlay 网络的容器提供访问外网的能力 [root@node-2 ~]# docker network ls [root@node-2 ~]# docker network inspect docker_gwbridge 从 docker network inspect docker_gwbridge 输出可确认 docker_gwbridge 的 IP 地址范围是 172.18.0.0/16，当前连接的容器就是 bbox-1（172.18.0.2）\n而且此网络的网关就是网桥 docker_gwbridge 的 IP 172.18.0.1\n[root@node-2 ~]# ifconfig docker_gwbridge docker_gwbridge: flags=4163 mtu 1500 inet 172.18.0.1 netmask 255.255.0.0 broadcast 172.18.255.255 inet6 fe80::42:c5ff:fe45:937 prefixlen 64 scopeid 0x20 ether 02:42:c5:45:09:37 txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 这样容器 bbox-1 就可以通过 docker_gwbridge 访问外网\n[root@node-2 ~]# docker exec bbox-1 ping -c 4 www.baidu.com PING www.baidu.com (182.61.200.6): 56 data bytes 64 bytes from 182.61.200.6: seq=0 ttl=53 time=6.721 ms 64 bytes from 182.61.200.6: seq=1 ttl=53 time=7.954 ms 64 bytes from 182.61.200.6: seq=2 ttl=53 time=11.723 ms 64 bytes from 182.61.200.6: seq=3 ttl=53 time=15.105 ms --- www.baidu.com ping statistics --- 4 packets transmitted, 4 packets received, 0% packet loss round-trip min/avg/max = 6.721/10.375/15.105 ms 5.5 overlay 网络连通性 node-3 中 运行 bbox-2 [root@node-3 ~]# docker run -itd --name bbox-2 --network ov_net1 busybox 查看 bbox-2 路由情况 [root@node-3 ~]# docker exec bbox-2 ip r default via 172.18.0.1 dev eth1 10.0.0.0/24 dev eth0 scope link src 10.0.0.3 172.18.0.0/16 dev eth1 scope link src 172.18.0.2 互通测试 [root@node-3 ~]# docker exec bbox-2 ping -c 4 10.0.0.2 PING 10.0.0.2 (10.0.0.2): 56 data bytes 64 bytes from 10.0.0.2: seq=0 ttl=64 time=2.628 ms 64 bytes from 10.0.0.2: seq=1 ttl=64 time=1.004 ms 64 bytes from 10.0.0.2: seq=2 ttl=64 time=1.277 ms 64 bytes from 10.0.0.2: seq=3 ttl=64 time=1.505 ms --- 10.0.0.2 ping statistics --- 4 packets transmitted, 4 packets received, 0% packet loss round-trip min/avg/max = 1.004/1.603/2.628 ms 可见 overlay 网络中的容器可以直接通信，同时 docker 也实现了 DNS 服务\n实现原理 docker 会为每个 overlay 网络创建一个独立的 network namespace，其中会有一个 linux bridge br0， veth pair 一端连接到容器中（即 eth0），另一端连接到 namespace 的 br0 上。\nbr0 除了连接所有的 veth pair，还会连接一个 vxlan 设备，用于与其他 host 建立 vxlan tunnel。容器之间的数据就是通过这个 tunnel 通信的。逻辑网络拓扑结构如图所示：\n[root@node-2 ~]# brctl show bridge name bridge id STP enabled interfaces docker0 8000.024217edc413 no docker_gwbridge 8000.0242c5450937 no vethc59120e virbr0 8000.525400b76fd4 yes virbr0-nic [root@node-3 ~]# brctl show bridge name bridge id STP enabled interfaces docker0 8000.0242ef3c7df7 no docker_gwbridge 8000.0242c81afaee no vethf4562a9 virbr0 8000.525400c28478 yes virbr0-nic 要查看 overlay 网络的 namespace 可以在 node-2 和 node-3 上执行 ip netns（请确保在此之前执行过 ln -s /var/run/docker/netns /var/run/netns），可以看到两个 node 上有一个相同的 namespace “1-dd91de7599”\n[root@node-2 ~]# ln -s /var/run/docker/netns /var/run/netns [root@node-2 ~]# ip netns 6889f61efc4b (id: 1) 1-dd91de7599 (id: 0) [root@node-3 ~]# ln -s /var/run/docker/netns /var/run/netns [root@node-3 ~]# ip netns 8e4722847745 (id: 1) 1-dd91de7599 (id: 0) “1-dd91de7599” 这就是 ov_net1 的 namespace，查看 namespace 中的 br0 上的设备\n[root@node-2 ~]# ip netns exec 1-dd91de7599 brctl show bridge name bridge id STP enabled interfaces br0 8000.0e7576c7c035 no veth0 vxlan0 5.6 overlay 网络隔离 不同的 overlay 网络是相互隔离的。我们创建第二个 overlay 网络 ov_net2 并运行容器 bbox-3\n创建网络 ov_net2 [root@node-2 ~]# docker network create -d overlay ov_net2 启动容器 bbox-3 [root@node-2 ~]# docker run -itd --name bbox-3 --network ov_net2 busybox 查看 bbox-3 网络 bbox-3 分配到的 IP 是 10.0.1.2，尝试 ping bbox-1（10.0.0.2）\n[root@node-2 ~]# docker exec -it bbox-3 ip r default via 172.18.0.1 dev eth1 10.0.1.0/24 dev eth0 scope link src 10.0.1.2 172.18.0.0/16 dev eth1 scope link src 172.18.0.3 [root@node-2 ~]# docker exec -it bbox-3 ping -c 4 10.0.0.2 PING 10.0.0.2 (10.0.0.2): 56 data bytes --- 10.0.0.2 ping statistics --- 4 packets transmitted, 0 packets received, 100% packet loss [root@node-2 ~]# docker exec -it bbox-3 ping -c 4 172.18.0.2 PING 172.18.0.2 (172.18.0.2): 56 data bytes --- 172.18.0.2 ping statistics --- 4 packets transmitted, 0 packets received, 100% packet loss ping 失败，可见不同 overlay 网络之间是隔离的，即使通过 docker_gwbridge 也不能通信\n如果要实现 bbox-3 和 bbox-1 通信，可以将 bbox-3 也连接到 ov_net1\n这时 bbox-3 同时连接到了 ov_net1 和 ov_net2 上\n[root@node-2 ~]# docker network connect ov_net1 bbox-3 [root@node-2 ~]# docker exec bbox-3 ip r default via 172.18.0.1 dev eth1 10.0.0.0/24 dev eth2 scope link src 10.0.0.4 10.0.1.0/24 dev eth0 scope link src 10.0.1.2 172.18.0.0/16 dev eth1 scope link src 172.18.0.3 [root@node-2 ~]# docker exec bbox-3 ping -c 4 10.0.0.2 PING 10.0.0.2 (10.0.0.2): 56 data bytes 64 bytes from 10.0.0.2: seq=0 ttl=64 time=0.184 ms 64 bytes from 10.0.0.2: seq=1 ttl=64 time=0.158 ms 64 bytes from 10.0.0.2: seq=2 ttl=64 time=0.162 ms 64 bytes from 10.0.0.2: seq=3 ttl=64 time=0.093 ms --- 10.0.0.2 ping statistics --- 4 packets transmitted, 4 packets received, 0% packet loss round-trip min/avg/max = 0.093/0.149/0.184 ms docker 默认为 overlay 网络分配 24 位掩码的子网（10.0.X.0/24），所有主机共享这个 subnet，容器启动时会顺序从此空间分配 IP。当然我们也可以通过 –subnet 指定 IP 空间。\ndocker network create -d overlay --subnet 10.22.1.0/24 ov_net 以上\n","wordCount":"3402","inLanguage":"en","image":"https://image.lvbibir.cn/blog/docker.png","datePublished":"2019-08-01T00:00:00Z","dateModified":"2024-01-28T00:00:00Z","author":{"@type":"Person","name":"lvbibir"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.lvbibir.cn/en/posts/tech/docker-rong-qi-kua-zhu-ji-lian-jie/"},"publisher":{"@type":"Organization","name":"lvbibir's Blog","logo":{"@type":"ImageObject","url":"https://www.lvbibir.cn/img/avatar.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.lvbibir.cn/en/ accesskey=h title="lvbibir's Blog (Alt + H)"><img src=https://www.lvbibir.cn/img/avatar.gif alt aria-label=logo height=35>lvbibir's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li class=menu-item><a href=https://www.lvbibir.cn/en/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li class=menu-item><a href=https://www.lvbibir.cn/en/posts title="📚 文章"><span>📚 文章</span></a></li><li class=menu-item><a href=https://www.lvbibir.cn/en/archives title="📈 归档"><span>📈 归档</span></a></li><li class=menu-item><a href=https://www.lvbibir.cn/en/talk title="💬 说说"><span>💬 说说</span></a></li><li class=menu-item><a href=https://www.lvbibir.cn/en/links title="🤝 友链"><span>🤝 友链</span></a></li></ul></nav></header><main class="main page"><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://www.lvbibir.cn/en/>主页</a></div><h1 class=post-title>docker | 容器的跨主机连接</h1><div class=post-description>介绍 docker 容器在不同宿主机下实现通信的几种方案</div><div class=post-meta>创建:&amp;nbsp;&lt;span title='2019-08-01 00:00:00 +0000 UTC'>2019-08-01&lt;/span>&amp;nbsp;|&amp;nbsp;更新:&amp;nbsp;2024-01-28&amp;nbsp;|&amp;nbsp;字数:&amp;nbsp;3402字&amp;nbsp;|&amp;nbsp;作者:&amp;nbsp;lvbibir
|&nbsp;标签:&nbsp;<ul class=post-tags-meta><a href=https://www.lvbibir.cn/en/tags/docker/>docker</a></ul><span id=busuanzi_container_page_pv>&nbsp;|&nbsp;访问:&nbsp;<span id=busuanzi_value_page_pv></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>文章目录</span></summary><div class=inner><ul><li><a href=#0-%e5%89%8d%e8%a8%80 aria-label="0 前言">0 前言</a></li><li><a href=#1-%e7%bd%91%e6%a1%a5 aria-label="1 网桥">1 网桥</a></li><li><a href=#2-open-vswitch aria-label="2 open vswitch">2 open vswitch</a></li><li><a href=#3-weave aria-label="3 weave">3 weave</a></li><li><a href=#4-macvlan aria-label="4 macvlan">4 macvlan</a><ul><li><a href=#41-%e7%ae%80%e4%bb%8b aria-label="4.1 简介">4.1 简介</a></li><li><a href=#42-%e9%83%a8%e7%bd%b2 aria-label="4.2 部署">4.2 部署</a></li><li><a href=#43-%e4%b8%80%e5%9d%97%e7%bd%91%e5%8d%a1%e7%bb%91%e5%ae%9a%e5%a4%9a%e4%b8%aa-macvlan-%e5%9c%b0%e5%9d%80 aria-label="4.3 一块网卡绑定多个 macvlan 地址">4.3 一块网卡绑定多个 macvlan 地址</a></li></ul></li><li><a href=#5-overlay aria-label="5 overlay">5 overlay</a><ul><li><a href=#51-%e7%ae%80%e4%bb%8b aria-label="5.1 简介">5.1 简介</a></li><li><a href=#52-%e5%87%86%e5%a4%87-overlay-%e7%8e%af%e5%a2%83 aria-label="5.2 准备 overlay 环境">5.2 准备 overlay 环境</a></li><li><a href=#53-%e5%88%9b%e5%bb%ba-overlay-%e7%bd%91%e7%bb%9c aria-label="5.3 创建 overlay 网络">5.3 创建 overlay 网络</a></li><li><a href=#54-%e5%9c%a8-overlay-%e4%b8%ad%e8%bf%90%e8%a1%8c%e5%ae%b9%e5%99%a8 aria-label="5.4 在 overlay 中运行容器">5.4 在 overlay 中运行容器</a></li><li><a href=#55-overlay-%e7%bd%91%e7%bb%9c%e8%bf%9e%e9%80%9a%e6%80%a7 aria-label="5.5 overlay 网络连通性">5.5 overlay 网络连通性</a></li><li><a href=#56-overlay-%e7%bd%91%e7%bb%9c%e9%9a%94%e7%a6%bb aria-label="5.6 overlay 网络隔离">5.6 overlay 网络隔离</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=0-前言>0 前言<a hidden class=anchor aria-hidden=true href=#0-前言>#</a></h1><p>实现跨主机的 docker 容器之间的通讯：</p><ol><li>使用网桥实现跨主机的连接</li><li>docker 原生的网络：overlay、macvlan</li><li>第三方网络：flaanel、weave、calic</li></ol><h1 id=1-网桥>1 网桥<a hidden class=anchor aria-hidden=true href=#1-网桥>#</a></h1><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190815125207352.png alt=在这里插入图片描述></p><h1 id=2-open-vswitch>2 open vswitch<a hidden class=anchor aria-hidden=true href=#2-open-vswitch>#</a></h1><h1 id=3-weave>3 weave<a hidden class=anchor aria-hidden=true href=#3-weave>#</a></h1><h1 id=4-macvlan>4 macvlan<a hidden class=anchor aria-hidden=true href=#4-macvlan>#</a></h1><h2 id=41-简介>4.1 简介<a hidden class=anchor aria-hidden=true href=#41-简介>#</a></h2><p>macvlan 是 Linux 操作系统内核提供的网络虚拟化方案之一，更准确的说法是网卡虚拟化方案。它可以为一张物理网卡设置多个 mac 地址，相当于物理网卡施展了影分身之术，由一个变多个，同时要求物理网卡打开混杂模式。针对每个 mac 地址，都可以设置 IP 地址，本来是一块物理网卡连接到交换机，现在是多块虚拟网卡连接到交换机。</p><p>当容器需要直连入物理网络时，可以使用 Macvlan。Macvlan 本身不创建网络，本质上首先使宿主机物理网卡工作在‘混杂模式’，这样物理网卡的 MAC 地址将会失效，所有二层网络中的流量物理网卡都能收到。接下来就是在这张物理网卡上创建虚拟网卡，并为虚拟网卡指定 MAC 地址，实现一卡多用，在物理网络看来，每张虚拟网卡都是一个单独的接口。使用 Macvlan 有几点需要注意：</p><ul><li>容器直接连接物理网络，由物理网络负责分配 IP 地址，可能的结果是物理网络 IP 地址被耗尽，另一个后果是网络性能问题，物理网络中接入的主机变多，广播包占比快速升高而引起的网络性能下降问题。</li><li>前边说过了，宿主机上的某张网上需要工作在‘混乱模式’下。</li><li>从长远来看 bridge 网络与 overlay 网络是更好的选择，原因就是虚拟网络应该与物理网络隔离而不是共享。</li></ul><p>优缺点：</p><ul><li>优点是性能非常好</li><li>缺点是地址需要手动分配</li></ul><p>Macvlan 网络有两种模式：bridge 模式与 802.1q trunk bridge 模式。</p><ul><li>bridge 模式，Macvlan 网络流量直接使用宿主机物理网卡。</li><li>802.1q trunk bridge 模式，Macvlan 网络流量使用 Docker 动态创建的 802.1q 子接口，对于路由与过虑，这种模式能够提供更细粒度的控制</li></ul><h2 id=42-部署>4.2 部署<a hidden class=anchor aria-hidden=true href=#42-部署>#</a></h2><p>环境准备：</p><ol><li>两台 centos7</li><li>docker 版本：18.03</li><li>ip：192.168.0.53（node-1） 192.168.0.54（node-2）</li></ol><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># ip link show ens33</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># ip link set ens32 promisc on</span>
</span></span><span style=display:flex><span><span style=color:#776e71>#开启混杂模式，保证多个ip可以通过</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network create -d macvlan --subnet 10.0.0.0/24 --gateway=10.0.0.1 -o parent=ens33 mac_net1</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network ls</span>
</span></span></code></pre></div><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190818182057577.png alt=在这里插入图片描述></p><ul><li>node-1</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -itd --name bbox-1 --ip 10.0.0.11 --network mac_net1 busybox
</span></span></code></pre></div><ul><li>node-2</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -itd --name bbox-2 --ip 10.0.0.12 --network mac_net1 busybox
</span></span></code></pre></div><ul><li>node-1</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec bbox-1 ping 10.0.0.12</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec bbox-1 ping bbox-2</span>
</span></span></code></pre></div><p>可以 ping 通 ip，但是无法 ping 通主机名，因为它没有 dns 解析</p><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190818182937702.png alt=在这里插入图片描述></p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># brctl show</span>
</span></span></code></pre></div><p>因为 macvlan 不依赖于 bridge 网络，所以查看不到新的桥接网络</p><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190818183048914.png alt=在这里插入图片描述></p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec bbox-1  ip link</span>
</span></span></code></pre></div><p>查看到 eth0 连接到了 if2</p><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190818183317728.png alt=在这里插入图片描述></p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># ip link show ens33</span>
</span></span></code></pre></div><p>可以查看到 ens33 的编号是 2，即 bbox-1 容器的 eth0 网卡连接到了 ens33 物理网卡</p><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190818183502889.png alt=在这里插入图片描述></p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network create  -d macvlan -o parent=ens33 mac_net2</span>
</span></span><span style=display:flex><span>Error response from daemon: network dm-b34ee1020a96 is already using parent interface ens33
</span></span></code></pre></div><p>再创建 macvlan 网络时发现已经无法再创建，即一块网卡只能添加一个 macvlan 的地址</p><h2 id=43-一块网卡绑定多个-macvlan-地址>4.3 一块网卡绑定多个 macvlan 地址<a hidden class=anchor aria-hidden=true href=#43-一块网卡绑定多个-macvlan-地址>#</a></h2><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># modinfo 8021q</span>
</span></span><span style=display:flex><span><span style=color:#776e71># 查看内核是否支持802.1q封装</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># modprobe 8021q</span>
</span></span><span style=display:flex><span><span style=color:#776e71># 如果上条命令执行后没有结果，使用该命令加载该模块</span>
</span></span></code></pre></div><ul><li>node-1</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># vim /etc/sysconfig/network-scripts/ifcfg-ens33</span>
</span></span><span style=display:flex><span><span style=color:#ef6155>BOOTPROTO</span><span style=color:#5bc4bf>=</span>manual
</span></span></code></pre></div><p>修改为不需要 ip 的 manual 模式</p><ul><li>node-2</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># vim /etc/sysconfig/network-scripts/ifcfg-ens32</span>
</span></span><span style=display:flex><span><span style=color:#ef6155>BOOTPROTO</span><span style=color:#5bc4bf>=</span>manual
</span></span></code></pre></div><ul><li>node-1</li></ul><p>添加两块虚拟网卡，注意与实际的 ens32 网卡的网段区分开</p><p>ens32 使用的是 192.168.0.0/24 网段，虚拟网卡使用的是 192.168.1.0/24 和 192.168.2.0/24</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># cp -p /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-ens33.10</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># vim /etc/sysconfig/network-scripts/ifcfg-ens33.10</span>
</span></span><span style=display:flex><span><span style=color:#ef6155>BOOTPROTO</span><span style=color:#5bc4bf>=</span>none
</span></span><span style=display:flex><span><span style=color:#ef6155>NAME</span><span style=color:#5bc4bf>=</span>ens33.10
</span></span><span style=display:flex><span><span style=color:#ef6155>DEVICE</span><span style=color:#5bc4bf>=</span>ens33.10
</span></span><span style=display:flex><span><span style=color:#ef6155>ONBOOT</span><span style=color:#5bc4bf>=</span>yes
</span></span><span style=display:flex><span><span style=color:#ef6155>IPADDR</span><span style=color:#5bc4bf>=</span>192.168.1.10
</span></span><span style=display:flex><span><span style=color:#ef6155>PREFIX</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>24</span>
</span></span><span style=display:flex><span><span style=color:#ef6155>NETWORK</span><span style=color:#5bc4bf>=</span>192.168.1.0
</span></span><span style=display:flex><span><span style=color:#ef6155>VLAN</span><span style=color:#5bc4bf>=</span>yes
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># cp -p /etc/sysconfig/network-scripts/ifcfg-ens33.10 /etc/sysconfig/network-scripts/ifcfg-ens33.20</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># vim /etc/sysconfig/network-scripts/ifcfg-ens33.20</span>
</span></span><span style=display:flex><span><span style=color:#ef6155>BOOTPROTO</span><span style=color:#5bc4bf>=</span>none
</span></span><span style=display:flex><span><span style=color:#ef6155>NAME</span><span style=color:#5bc4bf>=</span>ens33.20
</span></span><span style=display:flex><span><span style=color:#ef6155>DEVICE</span><span style=color:#5bc4bf>=</span>ens33.20
</span></span><span style=display:flex><span><span style=color:#ef6155>ONBOOT</span><span style=color:#5bc4bf>=</span>yes
</span></span><span style=display:flex><span><span style=color:#ef6155>IPADDR</span><span style=color:#5bc4bf>=</span>192.168.2.10
</span></span><span style=display:flex><span><span style=color:#ef6155>PREFIX</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>24</span>
</span></span><span style=display:flex><span><span style=color:#ef6155>NETWORK</span><span style=color:#5bc4bf>=</span>192.168.2.0
</span></span><span style=display:flex><span><span style=color:#ef6155>VLAN</span><span style=color:#5bc4bf>=</span>yes
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># ifup ens33.10</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># ifup ens33.20</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># scp /etc/sysconfig/network-scripts/ifcfg-ens33.10 192.168.0.54:/etc/sysconfig/network-scripts/ifcfg-ens32.10</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># scp /etc/sysconfig/network-scripts/ifcfg-ens33.20 192.168.0.54:/etc/sysconfig/network-scripts/ifcfg-ens32.20</span>
</span></span></code></pre></div><ul><li>node-2</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># vim /etc/sysconfig/network-scripts/ifcfg-ens32.10</span>
</span></span><span style=display:flex><span><span style=color:#ef6155>BOOTPROTO</span><span style=color:#5bc4bf>=</span>none
</span></span><span style=display:flex><span><span style=color:#ef6155>NAME</span><span style=color:#5bc4bf>=</span>ens32.10
</span></span><span style=display:flex><span><span style=color:#ef6155>DEVICE</span><span style=color:#5bc4bf>=</span>ens32.10
</span></span><span style=display:flex><span><span style=color:#ef6155>ONBOOT</span><span style=color:#5bc4bf>=</span>yes
</span></span><span style=display:flex><span><span style=color:#ef6155>IPADDR</span><span style=color:#5bc4bf>=</span>192.168.1.20
</span></span><span style=display:flex><span><span style=color:#ef6155>PREFIX</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>24</span>
</span></span><span style=display:flex><span><span style=color:#ef6155>NETWORK</span><span style=color:#5bc4bf>=</span>192.168.1.0
</span></span><span style=display:flex><span><span style=color:#ef6155>VLAN</span><span style=color:#5bc4bf>=</span>yes
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># vim /etc/sysconfig/network-scripts/ifcfg-ens32.20</span>
</span></span><span style=display:flex><span><span style=color:#ef6155>BOOTPROTO</span><span style=color:#5bc4bf>=</span>none
</span></span><span style=display:flex><span><span style=color:#ef6155>NAME</span><span style=color:#5bc4bf>=</span>ens32.20
</span></span><span style=display:flex><span><span style=color:#ef6155>DEVICE</span><span style=color:#5bc4bf>=</span>ens32.20
</span></span><span style=display:flex><span><span style=color:#ef6155>ONBOOT</span><span style=color:#5bc4bf>=</span>yes
</span></span><span style=display:flex><span><span style=color:#ef6155>IPADDR</span><span style=color:#5bc4bf>=</span>192.168.2.20
</span></span><span style=display:flex><span><span style=color:#ef6155>PREFIX</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>24</span>
</span></span><span style=display:flex><span><span style=color:#ef6155>NETWORK</span><span style=color:#5bc4bf>=</span>192.168.2.0
</span></span><span style=display:flex><span><span style=color:#ef6155>VLAN</span><span style=color:#5bc4bf>=</span>yes
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># ifup ens32.10</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># ifup ens32.20</span>
</span></span></code></pre></div><ul><li>node-1</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network create -d macvlan --subnet 172.16.11.0/24 --gateway 172.16.11.1 -o parent=ens33.10 mac_net11</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network create -d macvlan --subnet 172.16.12.0/24 --gateway 172.16.12.1 -o parent=ens33.20 mac_net12</span>
</span></span></code></pre></div><ul><li>node-2</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network create -d macvlan --subnet 172.16.11.0/24 --gateway 172.16.11.1 -o parent=ens32.10 mac_net11</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network create -d macvlan --subnet 172.16.12.0/24 --gateway 172.16.12.1 -o parent=ens32.20 mac_net12</span>
</span></span></code></pre></div><ul><li>node-1</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -itd --name bbox-11 --ip=172.16.11.11 --network mac_net11 busybox</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -itd --name bbox-12 --ip=172.16.12.11 --network mac_net12 busybox</span>
</span></span></code></pre></div><ul><li>node-2</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -itd --name bbox-21 --ip=172.16.11.12 --network mac_net11 busybox</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -itd --name bbox-22 --ip=172.16.12.12 --network mac_net12 busybox</span>
</span></span></code></pre></div><ul><li>node-1</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec bbox-11 ping 172.16.11.12</span>
</span></span><span style=display:flex><span>PING 172.16.11.12 <span style=color:#5bc4bf>(</span>172.16.11.12<span style=color:#5bc4bf>)</span>: <span style=color:#f99b15>56</span> data bytes
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 172.16.11.12: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>0</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>0.867 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 172.16.11.12: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>1</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>1.074 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 172.16.11.12: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>2</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>1.145 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 172.16.11.12: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>3</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>0.938 ms
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec bbox-12 ping 172.16.12.12</span>
</span></span><span style=display:flex><span>PING 172.16.12.12 <span style=color:#5bc4bf>(</span>172.16.12.12<span style=color:#5bc4bf>)</span>: <span style=color:#f99b15>56</span> data bytes
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 172.16.12.12: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>0</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>0.858 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 172.16.12.12: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>1</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>1.140 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 172.16.12.12: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>2</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>0.818 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 172.16.12.12: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>3</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>1.056 ms
</span></span><span style=display:flex><span>^C
</span></span></code></pre></div><ul><li>在两台系统进行修改，添加网关，修改防火墙策略</li><li>node-1 中记得将 ens32 更换为 ens33</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ifconfig ens32.10 172.16.10.1 netmask 255.255.255.0
</span></span><span style=display:flex><span>ifconfig ens32.20 172.16.20.1 netmask 255.255.255.0
</span></span><span style=display:flex><span>iptables -t nat -A POSTROUTING -o ens32.10 -j MASQUERADE
</span></span><span style=display:flex><span>iptables -t nat -A POSTROUTING -o ens32 -j MASQUERADE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iptables -A FORWARD -i ens32.10 -o ens32 -m state --state RELATE,ESTABLISHED -j ACCEPT
</span></span><span style=display:flex><span>iptables -A FORWARD -i ens32 -o ens32.10 -m state --state RELATE,ESTABLISHED -j ACCEPT
</span></span><span style=display:flex><span>iptables -A FORWARD -i ens32.10 -o ens32 -j ACCEPT
</span></span><span style=display:flex><span>iptables -A FORWARD -i ens32 -o ens32.10 -j ACCEPT
</span></span></code></pre></div><h1 id=5-overlay>5 overlay<a hidden class=anchor aria-hidden=true href=#5-overlay>#</a></h1><h2 id=51-简介>5.1 简介<a hidden class=anchor aria-hidden=true href=#51-简介>#</a></h2><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190819130602900.png alt=在这里插入图片描述></p><h2 id=52-准备-overlay-环境>5.2 准备 overlay 环境<a hidden class=anchor aria-hidden=true href=#52-准备-overlay-环境>#</a></h2><p>为支持容器的跨主机通信，Docker 提供了 overlay driver。Docker overlay 网络需要一个 key-value 数据库用于保存网络状态信息，包括 Network、Endpoint、IP 等。Consul、Etcd 和 ZooKeeper 都是 Docker 支持的 key-value 软件，这里我们使用 Consul</p><ol><li>环境描述</li></ol><table><thead><tr><th>节点</th><th>系统版本</th><th>docker 版本</th><th>角色</th><th>IP 地址</th></tr></thead><tbody><tr><td>node-1</td><td>centos7.4</td><td>docker-18.03.0</td><td>consul</td><td>192.168.0.101</td></tr><tr><td>node-2</td><td>centos7.4</td><td>docker-18.03.0</td><td>host</td><td>192.168.0.102</td></tr><tr><td>node-3</td><td>centos7.4</td><td>docker-18.03.0</td><td>host</td><td>192.168.0.103</td></tr></tbody></table><ol><li>创建 consul</li></ol><ul><li>node-1;</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-1 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -d -p 8500:8500 -h consul --name consul progrium/consul -server -bootstrap</span>
</span></span></code></pre></div><p>容器启动后可以通过 192.168.0.101:8500 访问到 consul</p><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190819224043952.png alt=在这里插入图片描述></p><ol><li>修改 docker 配置文件</li></ol><p>修改 node-2 和 node-3 的 docker daemon 的配置文件/etc/systemd/system/docker.service</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># vim  /etc/systemd/system/docker.service</span>
</span></span><span style=display:flex><span><span style=color:#ef6155>ExecStart</span><span style=color:#5bc4bf>=</span>/usr/bin/dockerd  -H tcp://0.0.0.0:2376 -H unix:///var/run/docker.sock --cluster-store<span style=color:#5bc4bf>=</span>consul://192.168.0.101:8500 --cluster-advertise<span style=color:#5bc4bf>=</span>ens32:2376
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># systemctl daemon-reload</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># systemctl restart docker</span>
</span></span></code></pre></div><ul><li>-H ：tcp：允许 tcp 连接 daemon
-H：unix：默认的 socket 连接方式，支持远程的同时，本地也可以连接</li><li>&ndash;cluster-store 指定 consul 的地址</li><li>&ndash;cluster-advertise 告知 consul 自己的连接地址</li></ul><p>node-2 和 node-3 会自动注册到 consul 数据库中。</p><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190819225334857.png alt=在这里插入图片描述></p><h2 id=53-创建-overlay-网络>5.3 创建 overlay 网络<a hidden class=anchor aria-hidden=true href=#53-创建-overlay-网络>#</a></h2><ol><li>在 node-2 中创建网络</li></ol><p>在 node-2 中创建 overlay 网络 ov_net1</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network create -d overlay ov_net1</span>
</span></span></code></pre></div><ul><li>-d overlay：指定 driver 为 overlay</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network ls</span>
</span></span></code></pre></div><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190819225928983.png alt=在这里插入图片描述></p><ol><li>node-3 查看创建的网络</li></ol><p>注意到 ov_net1 的 SCOPE 为 global，而其他网络为 local 。在 node-3 上查看存在的网络:</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-3 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network ls</span>
</span></span></code></pre></div><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190819230148207.png alt=在这里插入图片描述></p><p>node-3 上也能看到 ov_net1，只是因为创建 ov_net1 时将 overlay 网络信息存入了 consul，node-3 从 consul 读取到了新网络数据。之后 ov_net1 的任何变化都会同步到 node-2 和 node-3</p><ol><li>查看 ov_net1 详细信息</li></ol><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network inspect ov_net1</span>
</span></span></code></pre></div><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190819230439425.png alt=在这里插入图片描述></p><p>IPAM 是指 IP Address Management，docker 自动为 ov_net1 分配的 IP 空间为 10.0.0.0/24</p><h2 id=54-在-overlay-中运行容器>5.4 在 overlay 中运行容器<a hidden class=anchor aria-hidden=true href=#54-在-overlay-中运行容器>#</a></h2><ol><li>创建容器 bbox-1</li></ol><p>在 node-2 上运行一个 busybox 容器并连接到 ov_net1.</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -itd --name bbox-1 --network ov_net1 busybox</span>
</span></span></code></pre></div><ol><li>查看 bbox-1 网络配置</li></ol><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec bbox-1 ip r</span>
</span></span><span style=display:flex><span>default via 172.18.0.1 dev eth1
</span></span><span style=display:flex><span>10.0.0.0/24 dev eth0 scope link  src 10.0.0.2
</span></span><span style=display:flex><span>172.18.0.0/16 dev eth1 scope link  src 172.18.0.2
</span></span></code></pre></div><ul><li>bbox-1 有两个网络接口，eth0 和 eth1</li><li>eth0 IP 为 10.0.0.2，连接的是 overlay 网络 ov_net1</li><li>eth1 IP 为 172.18.0.2</li><li>容器的默认路由是走 eth1，其实，docker 会创建一个 bridge 网络 “docker_gwbridge”，为所有连接到 overlay 网络的容器提供访问外网的能力</li></ul><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network ls</span>
</span></span></code></pre></div><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190819231543466.png alt=在这里插入图片描述></p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network inspect docker_gwbridge</span>
</span></span></code></pre></div><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190819232009799.png alt=在这里插入图片描述></p><p>从 docker network inspect docker_gwbridge 输出可确认 docker_gwbridge 的 IP 地址范围是 172.18.0.0/16，当前连接的容器就是 bbox-1（172.18.0.2）</p><p>而且此网络的网关就是网桥 docker_gwbridge 的 IP 172.18.0.1</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># ifconfig docker_gwbridge</span>
</span></span><span style=display:flex><span>docker_gwbridge: <span style=color:#ef6155>flags</span><span style=color:#5bc4bf>=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span style=color:#f99b15>1500</span>
</span></span><span style=display:flex><span>        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255
</span></span><span style=display:flex><span>        inet6 fe80::42:c5ff:fe45:937  prefixlen <span style=color:#f99b15>64</span>  scopeid 0x20&lt;link&gt;
</span></span><span style=display:flex><span>        ether 02:42:c5:45:09:37  txqueuelen <span style=color:#f99b15>0</span>  <span style=color:#5bc4bf>(</span>Ethernet<span style=color:#5bc4bf>)</span>
</span></span><span style=display:flex><span>        RX packets <span style=color:#f99b15>0</span>  bytes <span style=color:#f99b15>0</span> <span style=color:#5bc4bf>(</span>0.0 B<span style=color:#5bc4bf>)</span>
</span></span><span style=display:flex><span>        RX errors <span style=color:#f99b15>0</span>  dropped <span style=color:#f99b15>0</span>  overruns <span style=color:#f99b15>0</span>  frame <span style=color:#f99b15>0</span>
</span></span><span style=display:flex><span>        TX packets <span style=color:#f99b15>0</span>  bytes <span style=color:#f99b15>0</span> <span style=color:#5bc4bf>(</span>0.0 B<span style=color:#5bc4bf>)</span>
</span></span><span style=display:flex><span>        TX errors <span style=color:#f99b15>0</span>  dropped <span style=color:#f99b15>0</span> overruns <span style=color:#f99b15>0</span>  carrier <span style=color:#f99b15>0</span>  collisions <span style=color:#f99b15>0</span>
</span></span></code></pre></div><p>这样容器 bbox-1 就可以通过 docker_gwbridge 访问外网</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec bbox-1 ping -c 4 www.baidu.com</span>
</span></span><span style=display:flex><span>PING www.baidu.com <span style=color:#5bc4bf>(</span>182.61.200.6<span style=color:#5bc4bf>)</span>: <span style=color:#f99b15>56</span> data bytes
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 182.61.200.6: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>0</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>53</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>6.721 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 182.61.200.6: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>1</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>53</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>7.954 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 182.61.200.6: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>2</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>53</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>11.723 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 182.61.200.6: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>3</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>53</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>15.105 ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>--- www.baidu.com ping statistics ---
</span></span><span style=display:flex><span><span style=color:#f99b15>4</span> packets transmitted, <span style=color:#f99b15>4</span> packets received, 0% packet loss
</span></span><span style=display:flex><span>round-trip min/avg/max <span style=color:#5bc4bf>=</span> 6.721/10.375/15.105 ms
</span></span></code></pre></div><h2 id=55-overlay-网络连通性>5.5 overlay 网络连通性<a hidden class=anchor aria-hidden=true href=#55-overlay-网络连通性>#</a></h2><ol><li>node-3 中 运行 bbox-2</li></ol><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-3 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -itd --name bbox-2 --network ov_net1 busybox</span>
</span></span></code></pre></div><ol><li>查看 bbox-2 路由情况</li></ol><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-3 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec bbox-2 ip r</span>
</span></span><span style=display:flex><span>default via 172.18.0.1 dev eth1
</span></span><span style=display:flex><span>10.0.0.0/24 dev eth0 scope link  src 10.0.0.3
</span></span><span style=display:flex><span>172.18.0.0/16 dev eth1 scope link  src 172.18.0.2
</span></span></code></pre></div><ol><li>互通测试</li></ol><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-3 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec bbox-2 ping -c 4 10.0.0.2</span>
</span></span><span style=display:flex><span>PING 10.0.0.2 <span style=color:#5bc4bf>(</span>10.0.0.2<span style=color:#5bc4bf>)</span>: <span style=color:#f99b15>56</span> data bytes
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 10.0.0.2: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>0</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>2.628 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 10.0.0.2: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>1</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>1.004 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 10.0.0.2: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>2</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>1.277 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 10.0.0.2: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>3</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>1.505 ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>--- 10.0.0.2 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#f99b15>4</span> packets transmitted, <span style=color:#f99b15>4</span> packets received, 0% packet loss
</span></span><span style=display:flex><span>round-trip min/avg/max <span style=color:#5bc4bf>=</span> 1.004/1.603/2.628 ms
</span></span></code></pre></div><p>可见 overlay 网络中的容器可以直接通信，同时 docker 也实现了 DNS 服务</p><ol><li>实现原理</li></ol><p>docker 会为每个 overlay 网络创建一个独立的 network namespace，其中会有一个 linux bridge br0， veth pair 一端连接到容器中（即 eth0），另一端连接到 namespace 的 br0 上。</p><p>br0 除了连接所有的 veth pair，还会连接一个 vxlan 设备，用于与其他 host 建立 vxlan tunnel。容器之间的数据就是通过这个 tunnel 通信的。逻辑网络拓扑结构如图所示：</p><p><img loading=lazy src=https://image.lvbibir.cn/blog/20190819233352547.png alt=在这里插入图片描述></p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># brctl show</span>
</span></span><span style=display:flex><span>bridge name     bridge id               STP enabled     interfaces
</span></span><span style=display:flex><span>docker0         8000.024217edc413       no
</span></span><span style=display:flex><span>docker_gwbridge         8000.0242c5450937       no              vethc59120e
</span></span><span style=display:flex><span>virbr0          8000.525400b76fd4       yes             virbr0-nic
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-3 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># brctl show</span>
</span></span><span style=display:flex><span>bridge name     bridge id               STP enabled     interfaces
</span></span><span style=display:flex><span>docker0         8000.0242ef3c7df7       no
</span></span><span style=display:flex><span>docker_gwbridge         8000.0242c81afaee       no              vethf4562a9
</span></span><span style=display:flex><span>virbr0          8000.525400c28478       yes             virbr0-nic
</span></span></code></pre></div><p>要查看 overlay 网络的 namespace 可以在 node-2 和 node-3 上执行 ip netns（请确保在此之前执行过 ln -s /var/run/docker/netns /var/run/netns），可以看到两个 node 上有一个相同的 namespace &ldquo;1-dd91de7599&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># ln -s /var/run/docker/netns /var/run/netns</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># ip netns</span>
</span></span><span style=display:flex><span>6889f61efc4b <span style=color:#5bc4bf>(</span>id: 1<span style=color:#5bc4bf>)</span>
</span></span><span style=display:flex><span>1-dd91de7599 <span style=color:#5bc4bf>(</span>id: 0<span style=color:#5bc4bf>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-3 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># ln -s /var/run/docker/netns /var/run/netns</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-3 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># ip netns</span>
</span></span><span style=display:flex><span>8e4722847745 <span style=color:#5bc4bf>(</span>id: 1<span style=color:#5bc4bf>)</span>
</span></span><span style=display:flex><span>1-dd91de7599 <span style=color:#5bc4bf>(</span>id: 0<span style=color:#5bc4bf>)</span>
</span></span></code></pre></div><p>&ldquo;1-dd91de7599&rdquo; 这就是 ov_net1 的 namespace，查看 namespace 中的 br0 上的设备</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># ip netns exec 1-dd91de7599 brctl show</span>
</span></span><span style=display:flex><span>bridge name     bridge id               STP enabled     interfaces
</span></span><span style=display:flex><span>br0             8000.0e7576c7c035       no              veth0
</span></span><span style=display:flex><span>                                                        vxlan0
</span></span></code></pre></div><h2 id=56-overlay-网络隔离>5.6 overlay 网络隔离<a hidden class=anchor aria-hidden=true href=#56-overlay-网络隔离>#</a></h2><p>不同的 overlay 网络是相互隔离的。我们创建第二个 overlay 网络 ov_net2 并运行容器 bbox-3</p><ol><li>创建网络 ov_net2</li></ol><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network create -d overlay ov_net2</span>
</span></span></code></pre></div><ol><li>启动容器 bbox-3</li></ol><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker run -itd --name bbox-3 --network ov_net2 busybox</span>
</span></span></code></pre></div><ol><li>查看 bbox-3 网络</li></ol><p>bbox-3 分配到的 IP 是 10.0.1.2，尝试 ping bbox-1（10.0.0.2）</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec -it bbox-3 ip r</span>
</span></span><span style=display:flex><span>default via 172.18.0.1 dev eth1
</span></span><span style=display:flex><span>10.0.1.0/24 dev eth0 scope link  src 10.0.1.2
</span></span><span style=display:flex><span>172.18.0.0/16 dev eth1 scope link  src 172.18.0.3
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec -it bbox-3 ping -c 4 10.0.0.2</span>
</span></span><span style=display:flex><span>PING 10.0.0.2 <span style=color:#5bc4bf>(</span>10.0.0.2<span style=color:#5bc4bf>)</span>: <span style=color:#f99b15>56</span> data bytes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>--- 10.0.0.2 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#f99b15>4</span> packets transmitted, <span style=color:#f99b15>0</span> packets received, 100% packet loss
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec -it bbox-3 ping -c 4 172.18.0.2</span>
</span></span><span style=display:flex><span>PING 172.18.0.2 <span style=color:#5bc4bf>(</span>172.18.0.2<span style=color:#5bc4bf>)</span>: <span style=color:#f99b15>56</span> data bytes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>--- 172.18.0.2 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#f99b15>4</span> packets transmitted, <span style=color:#f99b15>0</span> packets received, 100% packet loss
</span></span></code></pre></div><p>ping 失败，可见不同 overlay 网络之间是隔离的，即使通过 docker_gwbridge 也不能通信</p><p>如果要实现 bbox-3 和 bbox-1 通信，可以将 bbox-3 也连接到 ov_net1</p><p>这时 bbox-3 同时连接到了 ov_net1 和 ov_net2 上</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker network connect ov_net1 bbox-3</span>
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec bbox-3 ip r</span>
</span></span><span style=display:flex><span>default via 172.18.0.1 dev eth1
</span></span><span style=display:flex><span>10.0.0.0/24 dev eth2 scope link  src 10.0.0.4
</span></span><span style=display:flex><span>10.0.1.0/24 dev eth0 scope link  src 10.0.1.2
</span></span><span style=display:flex><span>172.18.0.0/16 dev eth1 scope link  src 172.18.0.3
</span></span><span style=display:flex><span><span style=color:#5bc4bf>[</span>root@node-2 ~<span style=color:#5bc4bf>]</span><span style=color:#776e71># docker exec bbox-3 ping -c 4 10.0.0.2</span>
</span></span><span style=display:flex><span>PING 10.0.0.2 <span style=color:#5bc4bf>(</span>10.0.0.2<span style=color:#5bc4bf>)</span>: <span style=color:#f99b15>56</span> data bytes
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 10.0.0.2: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>0</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>0.184 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 10.0.0.2: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>1</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>0.158 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 10.0.0.2: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>2</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>0.162 ms
</span></span><span style=display:flex><span><span style=color:#f99b15>64</span> bytes from 10.0.0.2: <span style=color:#ef6155>seq</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>3</span> <span style=color:#ef6155>ttl</span><span style=color:#5bc4bf>=</span><span style=color:#f99b15>64</span> <span style=color:#ef6155>time</span><span style=color:#5bc4bf>=</span>0.093 ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>--- 10.0.0.2 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#f99b15>4</span> packets transmitted, <span style=color:#f99b15>4</span> packets received, 0% packet loss
</span></span><span style=display:flex><span>round-trip min/avg/max <span style=color:#5bc4bf>=</span> 0.093/0.149/0.184 ms
</span></span></code></pre></div><p>docker 默认为 overlay 网络分配 24 位掩码的子网（10.0.X.0/24），所有主机共享这个 subnet，容器启动时会顺序从此空间分配 IP。当然我们也可以通过 &ndash;subnet 指定 IP 空间。</p><div class=highlight><pre tabindex=0 style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network create -d overlay --subnet 10.22.1.0/24 ov_net
</span></span></code></pre></div><p>以上</p></div><div class=post-reward><div style=padding:0;margin:0;width:100%;font-size:16px;text-align:center><div id=QR style=opacity:0><div id=wechat style=display:inline-block><a class=fancybox rel=group><img id=wechat_qr src=https://www.lvbibir.cn/img/wechat_pay.png alt=wechat_pay></a><p>微信</p></div><div id=alipay style=display:inline-block><a class=fancybox rel=group><img id=alipay_qr src=https://www.lvbibir.cn/img/alipay.png alt=alipay></a><p>支付宝</p></div></div><button id=rewardButton onclick='var qr=document.getElementById("QR");qr.style.opacity==="0"?qr.style.opacity="1":qr.style.opacity="0"'>
<span>🧧 鼓励</span></button></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://www.lvbibir.cn/en/posts/tech/docker-remote-call-daemon/><span class=title>« 上一页</span><br><span>docker | 守护进程的远程调用</span>
</a><a class=next href=https://www.lvbibir.cn/en/posts/tech/docker-commands/><span class=title>下一页 »</span><br><span>docker | 常见命令</span></a></nav></footer></div><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://cdn.staticfile.org/twikoo/1.6.15/twikoo.all.min.js></script><script>twikoo.init({envId:"https://twikoo.lvbibir.cn/",el:"#tcomment",lang:"zh-CN",path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><a href=https://gohugo.io/ target=_blank><img style=display:unset src=https://image.lvbibir.cn/blog/frame-hugo-blue.svg>
</a><a href=https://github.com/adityatelange/hugo-PaperMod target=_blank><img style=display:unset src=https://image.lvbibir.cn/blog/theme-papermod-lightgrey.svg>
</a><a href=https://cn.aliyun.com/ target=_blank><img style=display:unset src=https://image.lvbibir.cn/blog/图床-阿里云-orange.svg></a><br><span id=runtime_span></span>
<script type=text/javascript>function show_runtime(){window.setTimeout("show_runtime()",1e3),X=new Date("7/13/2021 1:00:00"),Y=new Date,T=Y.getTime()-X.getTime(),M=24*60*60*1e3,a=T/M,A=Math.floor(a),b=(a-A)*24,B=Math.floor(b),c=(b-B)*60,C=Math.floor((b-B)*60),D=Math.floor((c-C)*60),runtime_span.innerHTML="网站已运行"+A+"天"+B+"小时"+C+"分"+D+"秒"}show_runtime()</script>|
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container>总访客数: <span id=busuanzi_value_site_uv></span>
|
总访问量: <span id=busuanzi_value_site_pv></span></span><br><a href=https://beian.miit.gov.cn/ target=_blank style="border-bottom:1px solid">京ICP备2021023168号-1</a>&nbsp;
|
<span>Copyright
&copy;
2020-2024
<a href=https://www.lvbibir.cn/en/ style="border-bottom:1px solid">lvbibir's Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>400||document.documentElement.scrollTop>400?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="📄复制";function c(){t.innerText="👌🏻已复制!",setTimeout(()=>{t.innerText="📄复制"},2e3)}t.addEventListener("click",t=>{const n=document.createRange();n.selectNodeContents(e);const s=window.getSelection();s.removeAllRanges(),s.addRange(n);try{document.execCommand("copy"),c()}catch{}s.removeRange(n)});let l=e.className.replaceAll("language-",""),n=document.createElement("div"),i=document.createElement("div"),a=document.createElement("div"),r=document.createElement("div"),o=document.createElement("div");o.innerText=l,n.setAttribute("class","mac-tool"),i.setAttribute("class","mac bb1"),a.setAttribute("class","mac bb2"),r.setAttribute("class","mac bb3"),o.setAttribute("class","language-type"),n.appendChild(i),n.appendChild(a),n.appendChild(r),n.appendChild(o),s.classList.contains("highlight")?(s.appendChild(t),s.appendChild(n)):s.parentNode.firstChild===s||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName==="TABLE"?(e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t),s.appendChild(n)):(e.parentNode.appendChild(t),s.appendChild(n)))})</script></body></html>